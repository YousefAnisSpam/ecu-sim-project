<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Server Queue Simulation</title>
    <!-- Add SheetJS library for Excel export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Add jsPDF library for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- Add html2canvas for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* ============================================
           GLOBAL RESET & BASE STYLES
           ============================================ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #2c3e50);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: #333;
            line-height: 1.6;
        }

        /* ============================================
           CONTAINER & LAYOUT
           ============================================ */
        .container {
            width: 100%;
            max-width: 1800px;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            margin: 0 auto;
        }

        .content {
            background: white;
            padding: 30px;
            border-radius: 10px;
        }

        /* ============================================
           HEADER STYLES
           ============================================ */
        header {
            background: linear-gradient(135deg, #2c3e50, #4a6491);
            color: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 25px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: white;
        }

        h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 2rem;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 5px;
            color: rgba(255, 255, 255, 0.9);
        }

        /* ============================================
           BUTTON STYLES
           ============================================ */
        /* Back Button */
        .back-btn {
            padding: 10px 20px;
            background-color: #7f8c8d;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            margin-bottom: 25px;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .back-btn:hover {
            background-color: #6c7b7d;
        }

        /* Export Buttons */
        .export-buttons {
            display: flex;
            gap: 15px;
            margin: 25px 0;
            flex-wrap: wrap;
        }

        .export-btn {
            padding: 12px 25px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 180px;
        }

        .export-btn.pdf {
            background-color: #e74c3c;
        }

        .export-btn.pdf:hover {
            background-color: #c0392b;
        }

        .export-btn.excel {
            background-color: #2ecc71;
        }

        .export-btn.excel:hover {
            background-color: #27ae60;
        }

        .export-btn:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        /* Action Buttons */
        .add-row-btn, .remove-row-btn {
            padding: 10px 18px;
            margin: 8px 5px 8px 0;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .add-row-btn {
            background-color: #2ecc71;
            color: white;
        }

        .add-row-btn:hover {
            background-color: #27ae60;
        }

        .remove-row-btn {
            background-color: #e74c3c;
            color: white;
        }

        .remove-row-btn:hover {
            background-color: #c0392b;
        }

        .option-btn {
            padding: 12px 20px;
            border: 2px solid #3498db;
            background-color: white;
            color: #3498db;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            min-width: 200px;
        }

        .option-btn:hover, .option-btn.active {
            background-color: #3498db;
            color: white;
        }

        .simulate-btn {
            padding: 15px 40px;
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1rem;
            margin: 30px 0;
            transition: all 0.3s;
            display: block;
            margin-left: auto;
            margin-right: auto;
            width: 100%;
        }

        .simulate-btn:hover {
            background: linear-gradient(135deg, #27ae60, #219653);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(46, 204, 113, 0.3);
        }

        /* ============================================
           INPUT & FORM STYLES
           ============================================ */
        .input-section {
            margin: 30px 0;
            padding: 25px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border-left: 5px solid #3498db;
        }

        .input-group {
            margin: 20px 0;
        }

        .input-field {
            display: flex;
            flex-direction: column;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #34495e;
        }

        input[type="number"], 
        input[type="text"], 
        select, 
        textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }

        input:focus, 
        select:focus, 
        textarea:focus {
            outline: none;
            border-color: #4a6fa5;
            box-shadow: 0 0 0 2px rgba(74, 111, 165, 0.2);
        }

        .random-numbers-input {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
            font-family: 'Courier New', monospace;
            resize: vertical;
        }

        .input-hint {
            font-size: 0.85rem;
            color: #666;
            margin-top: 5px;
            font-style: italic;
        }

        /* ============================================
           SIMULATION LIMIT OPTIONS
           ============================================ */
        .limit-options {
            display: flex;
            gap: 20px;
            margin-top: 15px;
        }

        .limit-option {
            flex: 1;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.3s;
        }

        .limit-option:hover {
            border-color: #3498db;
            background-color: #f0f8ff;
        }

        .limit-option.selected {
            border-color: #2ecc71;
            background-color: #f0fff4;
        }

        .limit-input {
            margin-top: 10px;
            display: none;
        }

        .limit-input.active {
            display: block;
        }

        /* ============================================
           TABLE STYLES
           ============================================ */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 0.9rem;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: center;
        }

        th {
            background-color: #f2f6fc;
            font-weight: 600;
            color: #2c3e50;
        }

        .distribution-table {
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            margin: 20px 0;
            width: 100%;
        }

        .distribution-table th {
            background-color: #2c3e50;
            color: white;
            padding: 14px;
        }

        .distribution-table td {
            padding: 12px;
            border: 1px solid #e1e1e1;
        }

        .simulation-table-container {
            overflow-x: auto;
            margin: 30px 0;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            padding: 15px;
        }

        .simulation-table {
            width: 100%;
            min-width: 1400px;
            font-size: 0.85rem;
            border-collapse: collapse;
        }

        .simulation-table th {
            background-color: #2c3e50;
            color: white;
            padding: 12px 8px;
            position: sticky;
            top: 0;
            font-weight: 600;
        }

        .simulation-table td {
            padding: 10px 6px;
            border-bottom: 1px solid #eee;
            text-align: center;
        }

        .simulation-table tr:hover {
            background-color: #f5f9ff;
        }

        /* ============================================
           RNG CONFIGURATION STYLES
           ============================================ */
        .rng-section {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid #3498db;
        }
        
        .rng-methods {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .rng-method-btn {
            padding: 10px 20px;
            background-color: white;
            color: #3498db;
            border: 2px solid #3498db;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .rng-method-btn:hover, .rng-method-btn.active {
            background-color: #3498db;
            color: white;
        }
        
        .rng-params {
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            border: 1px solid #e0e0e0;
        }
        
        .rng-params-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .rng-params input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .rng-preview {
            margin-top: 15px;
            padding: 15px;
            background-color: #f0f8ff;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 200px;
            overflow-y: auto;
        }

        /* ============================================
           RESULTS SECTION STYLES
           ============================================ */
        .results-section {
            margin-top: 40px;
        }

        .results-header {
            color: #2c3e50;
            margin: 30px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }

        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }

        .summary-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.08);
            text-align: center;
            border-top: 5px solid #3498db;
        }

        .summary-card h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .summary-card .value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #2c3e50;
            margin: 10px 0;
        }

        .summary-card .unit {
            color: #7f8c8d;
            font-size: 0.85rem;
        }

        /* ============================================
           STATUS INDICATORS
           ============================================ */
        .probability-status {
            font-weight: bold;
            margin-left: 20px;
            padding: 8px 15px;
            border-radius: 5px;
            display: inline-block;
        }

        .probability-error {
            background-color: #ffeaea;
            color: #e74c3c;
        }

        .probability-ok {
            background-color: #e8f7ef;
            color: #27ae60;
        }

        /* ============================================
           SPECIAL ELEMENTS
           ============================================ */
        .warning {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 12px;
            border-radius: 5px;
            margin: 15px 0;
            font-size: 0.9rem;
        }

        .mapping-example {
            background-color: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 15px 0;
            font-size: 0.9rem;
        }

        .mapping-example strong {
            color: #2c3e50;
        }

        /* ============================================
           PRINT STYLES
           ============================================ */
        @media print {
            .back-btn, .option-buttons, .export-buttons, .add-row-btn, 
            .remove-row-btn, .simulate-btn, .footer, .input-section,
            .probability-status, .limit-options, .limit-input,
            .rng-section, .rng-methods, .rng-preview,
            .random-numbers-input, textarea, #arrivalRandoms, 
            #ableRandoms, #bakerRandoms, .input-group[class*="random"],
            .random-input-area, .warning {
                display: none !important;
            }
            
            .container {
                max-width: 100% !important;
                padding: 0 !important;
                margin: 0 !important;
                box-shadow: none !important;
                background-color: white !important;
            }
            
            body {
                background: white !important;
                padding: 0 !important;
                min-height: auto !important;
                display: block !important;
            }
            
            .content {
                padding: 10px !important;
                box-shadow: none !important;
                border-radius: 0 !important;
            }
            
            .simulation-table-container {
                overflow: visible !important;
                box-shadow: none !important;
                padding: 0 !important;
                margin: 10px 0 !important;
            }
            
            .simulation-table {
                font-size: 0.7rem !important;
                min-width: auto !important;
                width: 100% !important;
            }
            
            .distribution-table th, .simulation-table th {
                color: black !important;
                background-color: #f0f0f0 !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
                font-size: 0.8rem !important;
                padding: 6px 4px !important;
            }
            
            .distribution-table td, .simulation-table td {
                padding: 5px 3px !important;
                font-size: 0.7rem !important;
            }
            
            .summary-card {
                break-inside: avoid;
                box-shadow: none !important;
                border: 1px solid #ddd !important;
                margin: 5px 0 !important;
                padding: 10px !important;
            }
            
            .summary-card .value {
                font-size: 1.4rem !important;
            }
            
            .summary-cards {
                display: grid !important;
                grid-template-columns: repeat(3, 1fr) !important;
                gap: 10px !important;
                margin: 15px 0 !important;
            }
            
            header {
                background: white !important;
                color: black !important;
                box-shadow: none !important;
                border: 1px solid #ddd !important;
                padding: 15px !important;
                margin-bottom: 15px !important;
            }
            
            h1 {
                color: black !important;
                font-size: 1.8rem !important;
            }
            
            h2, h3, h4 {
                font-size: 1.2rem !important;
                margin: 10px 0 !important;
            }
            
            .subtitle {
                color: #666 !important;
            }
            
            .results-header {
                margin: 15px 0 10px 0 !important;
                padding-bottom: 5px !important;
                font-size: 1.1rem !important;
            }
            
            /* Ensure tables don't break across pages */
            table {
                page-break-inside: avoid !important;
            }
            
            tr {
                page-break-inside: avoid !important;
                page-break-after: auto !important;
            }
            
            /* Hide all input sections in print */
            div[class*="input"]:not(.input-section):not(.results-section) {
                display: none !important;
            }
        }

        /* ============================================
           FOOTER
           ============================================ */
        .footer {
            margin-top: 40px;
            text-align: center;
            color: #7f8c8d;
            font-size: 0.9rem;
            padding: 20px;
            border-top: 1px solid #eee;
        }

        /* ============================================
           RESPONSIVE DESIGN
           ============================================ */
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 15px;
            }
            
            .content {
                padding: 15px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .export-buttons, .option-buttons, .method-selector {
                flex-direction: column;
            }
            
            .export-btn, .option-btn, .method-btn {
                min-width: auto;
                width: 100%;
                justify-content: center;
            }
            
            .limit-options, .rng-configuration {
                flex-direction: column;
            }
            
            .input-group {
                flex-direction: column;
                align-items: flex-start;
            }
            
            input, select, textarea {
                width: 100%;
            }
            
            .rng-param-group {
                flex-direction: column;
                align-items: flex-start;
            }
        }

        @media (max-width: 480px) {
            .distribution-table {
                font-size: 0.8rem;
            }
            
            .distribution-table th, 
            .distribution-table td {
                padding: 8px 6px;
            }
            
            .simulation-table {
                font-size: 0.7rem;
            }
        }

        /* ============================================
           OPTION BUTTONS CONTAINER
           ============================================ */
        .option-buttons {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        /* Server-specific styles */
        .server-distributions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .server-priority {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        
        .priority-option {
            flex: 1;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .priority-option:hover {
            border-color: #3498db;
        }
        
        .priority-option.selected {
            border-color: #2ecc71;
            background-color: #f0fff4;
        }
        
        /* Server utilization cards */
        .server-utilization {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .server-card {
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        
        .server-card.able {
            background-color: #e8f4f8;
            border: 2px solid #3498db;
        }
        
        .server-card.baker {
            background-color: #fff3cd;
            border: 2px solid #ffc107;
        }
        
        .server-card h4 {
            margin-top: 0;
            color: #2c3e50;
        }
        
        .server-card .utilization {
            font-size: 2rem;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .server-card.able .utilization {
            color: #3498db;
        }
        
        .server-card.baker .utilization {
            color: #ffc107;
        }
        
        /* Simulation mode selector */
        .simulation-mode {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        
        .mode-option {
            flex: 1;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .mode-option:hover {
            border-color: #3498db;
        }
        
        .mode-option.selected {
            border-color: #2ecc71;
            background-color: #f0fff4;
        }
        
        .mode-description {
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            font-style: italic;
            color: #666;
        }
        
        /* Auto export section */
        .auto-export-section {
            background-color: #f0f8ff;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 20px;
            margin-top: 25px;
            text-align: center;
        }
        
        .auto-export-options {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .auto-export-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .auto-export-option input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }
        
        /* Table highlights */
        .highlight-able {
            background-color: #e8f4f8 !important;
        }
        
        .highlight-baker {
            background-color: #fff3cd !important;
        }
        
        .blank-data {
            color: #999;
            font-style: italic;
        }
        
        .server-header {
            background-color: #2c3e50 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Multi-Server Queue Simulation</h1>
            <p class="subtitle">Two-Server Call Center Simulation (Able & Baker)</p>
        </header>
        
        <div class="content">
            <button class="back-btn" onclick="window.location.href='index.html'">
                <i class="fas fa-arrow-left"></i> Back to Models
            </button>
            
            <h2>Two-Server Queue Simulation</h2>
            
            <div class="input-section">
                <h3>Simulation Parameters</h3>
                
                <div class="simulation-mode-selector">
                    <label>Simulation End Condition:</label>
                    <div class="simulation-mode">
                        <div class="mode-option selected" id="modeTime" onclick="selectSimulationMode('time')">
                            <h4>Time Limit</h4>
                            <p>Simulation ends when reaching specified time</p>
                        </div>
                        <div class="mode-option" id="modeCustomers" onclick="selectSimulationMode('customers')">
                            <h4>Customer Limit</h4>
                            <p>Simulation ends when serving specified number of customers</p>
                        </div>
                    </div>
                </div>
                
                <div class="mode-description" id="modeDescription">
                    Simulation will run for 60 minutes (1 hour) as in the PDF example
                </div>
                
                <div class="input-group" id="timeInputGroup">
                    <label for="simulationTime">Simulation Time (minutes):</label>
                    <input type="number" id="simulationTime" min="10" max="500" value="60">
                    <div class="input-hint">Simulation will stop when this time is reached</div>
                </div>
                
                <div class="input-group" id="customerInputGroup" style="display: none;">
                    <label for="numCustomers">Number of Customers to Serve:</label>
                    <input type="number" id="numCustomers" min="5" max="200" value="20">
                    <div class="input-hint">Simulation will stop when this many customers are served</div>
                </div>
                
                <!-- RNG Methods Section -->
                <div class="rng-section">
                    <h3>Random Number Generation Methods</h3>
                    <p>Generate random numbers using different algorithms:</p>
                    
                    <div class="rng-methods">
                        <button class="rng-method-btn active" onclick="selectRNGMethod('middleSquare')">Middle-Square Method</button>
                        <button class="rng-method-btn" onclick="selectRNGMethod('linearCongruential')">Linear Congruential Generator (LCG)</button>
                    </div>
                    
                    <!-- Middle-Square Method -->
                    <div class="rng-params" id="middleSquareConfig">
                        <h4>Middle-Square Method Parameters</h4>
                        <div class="rng-params-grid">
                            <div>
                                <label>Seed (any number):</label>
                                <input type="number" id="msSeed" value="7182" min="1" max="99999999">
                            </div>
                            <div>
                                <label>Count:</label>
                                <input type="number" id="msCount" value="30" min="10" max="200">
                            </div>
                        </div>
                        <div style="margin-top: 10px;">
                            <button class="option-btn" onclick="generateRNGNumbers('arrival')">Generate for Arrivals</button>
                            <button class="option-btn" onclick="generateRNGNumbers('able')">Generate for Able</button>
                            <button class="option-btn" onclick="generateRNGNumbers('baker')">Generate for Baker</button>
                        </div>
                    </div>
                    
                    <!-- Linear Congruential Generator -->
                    <div class="rng-params" id="linearCongruentialConfig" style="display: none;">
                        <h4>Linear Congruential Generator Parameters</h4>
                        <div class="rng-params-grid">
                            <div>
                                <label>Seed (Z₀):</label>
                                <input type="number" id="lcgSeed" value="7" min="1" max="1000">
                            </div>
                            <div>
                                <label>Multiplier (a):</label>
                                <input type="number" id="lcgMultiplier" value="5" min="1" max="1000">
                            </div>
                            <div>
                                <label>Increment (c):</label>
                                <input type="number" id="lcgIncrement" value="3" min="0" max="1000">
                            </div>
                            <div>
                                <label>Modulus (m):</label>
                                <input type="number" id="lcgModulus" value="16" min="2" max="10000">
                            </div>
                            <div>
                                <label>Count:</label>
                                <input type="number" id="lcgCount" value="30" min="10" max="200">
                            </div>
                        </div>
                        <div style="margin-top: 10px;">
                            <button class="option-btn" onclick="generateRNGNumbers('arrival')">Generate for Arrivals</button>
                            <button class="option-btn" onclick="generateRNGNumbers('able')">Generate for Able</button>
                            <button class="option-btn" onclick="generateRNGNumbers('baker')">Generate for Baker</button>
                        </div>
                    </div>
                    
                    <div id="rngPreview" class="rng-preview">
                        Generated numbers will appear here...
                    </div>
                </div>
                
                <!-- Auto Export Options -->
                <div class="auto-export-section">
                    <h3>Automatic Export Options</h3>
                    <div class="auto-export-options">
                        <div class="auto-export-option">
                            <input type="checkbox" id="autoExcel" checked>
                            <label for="autoExcel">Auto-export to Excel after simulation</label>
                        </div>
                        <div class="auto-export-option">
                            <input type="checkbox" id="autoPDF" checked>
                            <label for="autoPDF">Auto-generate PDF report after simulation</label>
                        </div>
                    </div>
                    <p style="margin-top: 10px; font-size: 0.9em; color: #666;">
                        These exports will automatically run after the simulation completes
                    </p>
                </div>

                <div class="input-group">
                    <label>When Both Servers Are Idle, Which Server Gets Priority?</label>
                    <div class="server-priority">
                        <div class="priority-option selected" id="priorityAble" onclick="selectPriority('able')">
                            <h4>Able (Server 1)</h4>
                            <p>Able gets priority when both servers are idle (Able is more experienced)</p>
                        </div>
                        <div class="priority-option" id="priorityBaker" onclick="selectPriority('baker')">
                            <h4>Baker (Server 2)</h4>
                            <p>Baker gets priority when both servers are idle</p>
                        </div>
                        <div class="priority-option" id="priorityRandom" onclick="selectPriority('random')">
                            <h4>Random</h4>
                            <p>Randomly assign to either server when both are idle</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="input-section">
                <h3>Interarrival Time Distribution</h3>
                <p>Define time between arrivals and their probabilities (Total must equal 1.0000):</p>
                
                <table class="distribution-table" id="arrivalDistributionTable">
                    <thead>
                        <tr>
                            <th>Time Between Arrivals (minutes)</th>
                            <th>Probability</th>
                            <th>Cumulative Probability</th>
                            <th>Random-Digit Assignment (01-100)</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody id="arrivalDistributionBody">
                        <!-- Rows will be added here -->
                    </tbody>
                </table>
                
                <div>
                    <button class="add-row-btn" onclick="addArrivalRow()">+ Add Arrival Time</button>
                    <button class="remove-row-btn" onclick="removeLastArrivalRow()">- Remove Last</button>
                    <span id="arrivalProbTotal" class="probability-status probability-error">Total Probability: 0.0000 (Should be 1.0000)</span>
                </div>
                
                <div class="mapping-example">
                    <strong>Example from PDF:</strong><br>
                    Time between arrivals: 1 (0.25), 2 (0.40), 3 (0.20), 4 (0.15)<br>
                    Random-digit assignments: 01–25, 26–65, 66–85, 86–00
                </div>
            </div>
            
            <div class="input-section">
                <h3>Service Time Distributions</h3>
                <p>Define service times for each server (Total must equal 1.0000 for each):</p>
                
                <div class="server-distributions">
                    <div>
                        <h4>Able (Server 1) Distribution</h4>
                        <table class="distribution-table" id="ableDistributionTable">
                            <thead>
                                <tr>
                                    <th>Service Time (minutes)</th>
                                    <th>Probability</th>
                                    <th>Cumulative Probability</th>
                                    <th>Random-Digit Assignment (01-100)</th>
                                    <th>Action</th>
                                </tr>
                            </thead>
                            <tbody id="ableDistributionBody">
                                <!-- Rows will be added here -->
                            </tbody>
                        </table>
                        
                        <div>
                            <button class="add-row-btn" onclick="addAbleRow()">+ Add Service Time</button>
                            <button class="remove-row-btn" onclick="removeLastAbleRow()">- Remove Last</button>
                            <span id="ableProbTotal" class="probability-status probability-error">Total Probability: 0.0000</span>
                        </div>
                    </div>
                    
                    <div>
                        <h4>Baker (Server 2) Distribution</h4>
                        <table class="distribution-table" id="bakerDistributionTable">
                            <thead>
                                <tr>
                                    <th>Service Time (minutes)</th>
                                    <th>Probability</th>
                                    <th>Cumulative Probability</th>
                                    <th>Random-Digit Assignment (01-100)</th>
                                    <th>Action</th>
                                </tr>
                            </thead>
                            <tbody id="bakerDistributionBody">
                                <!-- Rows will be added here -->
                            </tbody>
                        </table>
                        
                        <div>
                            <button class="add-row-btn" onclick="addBakerRow()">+ Add Service Time</button>
                            <button class="remove-row-btn" onclick="removeLastBakerRow()">- Remove Last</button>
                            <span id="bakerProbTotal" class="probability-status probability-error">Total Probability: 0.0000</span>
                        </div>
                    </div>
                </div>
                
                <div class="mapping-example">
                    <strong>Example from PDF:</strong><br>
                    <strong>Able:</strong> Service times: 2 (0.30), 3 (0.28), 4 (0.25), 5 (0.17)<br>
                    <strong>Baker:</strong> Service times: 3 (0.35), 4 (0.25), 5 (0.20), 6 (0.20)
                </div>
            </div>
            
            <div class="input-section">
                <h3>Random Numbers Input</h3>
                <p>Enter random numbers separated by commas (00-99):</p>
                
                <div class="warning">
                    <strong>Note:</strong> Random numbers 0-99 only. 100 means 00. Numbers >100 will be capped at 99.
                </div>
                
                <div class="option-buttons">
                    <button class="option-btn" onclick="generateArrivalRandoms()">
                        <i class="fas fa-random"></i> Generate Arrival Random Numbers
                    </button>
                    <button class="option-btn" onclick="generateAbleRandoms()">
                        <i class="fas fa-random"></i> Generate Able Service Random Numbers
                    </button>
                    <button class="option-btn" onclick="generateBakerRandoms()">
                        <i class="fas fa-random"></i> Generate Baker Service Random Numbers
                    </button>
                    <button class="option-btn" onclick="loadExampleFromPDF()">
                        <i class="fas fa-file-pdf"></i> Load PDF Example
                    </button>
                </div>
                
                <div class="input-group">
                    <label for="arrivalRandoms">Interarrival Random Numbers:</label>
                    <textarea id="arrivalRandoms" class="random-numbers-input random-input-area" placeholder="Enter comma-separated random numbers, e.g., 26, 98, 90, 26, 42" rows="3"></textarea>
                    <div class="input-hint" id="arrivalHint">Need random numbers for arrivals</div>
                </div>
                
                <div class="input-group">
                    <label for="ableRandoms">Able Service Random Numbers:</label>
                    <textarea id="ableRandoms" class="random-numbers-input random-input-area" placeholder="Enter comma-separated random numbers, e.g., 95, 21, 51, 92, 89" rows="3"></textarea>
                    <div class="input-hint" id="ableHint">Need random numbers for Able service</div>
                </div>
                
                <div class="input-group">
                    <label for="bakerRandoms">Baker Service Random Numbers:</label>
                    <textarea id="bakerRandoms" class="random-numbers-input random-input-area" placeholder="Enter comma-separated random numbers, e.g., 25, 36, 52, 45, 73" rows="3"></textarea>
                    <div class="input-hint" id="bakerHint">Need random numbers for Baker service</div>
                </div>
            </div>
            
            <!-- Export Buttons -->
            <div class="export-buttons" id="exportButtons" style="display: none;">
                <button class="export-btn pdf" onclick="generatePDFReport()">
                    <i class="fas fa-file-pdf"></i> Generate PDF Report
                </button>
                <button class="export-btn excel" onclick="exportToExcel()">
                    <i class="fas fa-file-excel"></i> Export to Excel
                </button>
            </div>
            
            <button class="simulate-btn" onclick="runMultiServerSimulation()">
                <i class="fas fa-play-circle"></i> Run Multi-Server Queue Simulation
            </button>
            
            <div class="results-section" id="resultsSection">
                <!-- Results will be inserted here -->
            </div>
        </div>
        
        <div class="footer">
            <p>Multi-Server Queue Simulation Tool © 2024 | Two-Server Call Center Model</p>
        </div>
    </div>
    
    <script>
        // Global variables
        let arrivalDistribution = [];
        let ableDistribution = [];
        let bakerDistribution = [];
        let priorityServer = 'able'; // Default: Able gets priority when both idle
        let simulationMode = 'time'; // Default: time-based simulation
        let currentRNGMethod = 'middleSquare';
        let simulationResults = null;
        let lastGeneratedNumbers = [];
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadExampleFromPDF();
            updateArrivalDistribution();
            updateAbleDistribution();
            updateBakerDistribution();
            updateRandomNumberHints();
        });
        
        // RNG Method Selection
        function selectRNGMethod(method) {
            currentRNGMethod = method;
            
            // Update UI
            const middleSquareBtn = document.querySelector('.rng-method-btn:first-child');
            const lcgBtn = document.querySelector('.rng-method-btn:last-child');
            const middleSquareDiv = document.getElementById('middleSquareConfig');
            const lcgDiv = document.getElementById('linearCongruentialConfig');
            
            if (method === 'middleSquare') {
                middleSquareBtn.classList.add('active');
                lcgBtn.classList.remove('active');
                middleSquareDiv.style.display = 'block';
                lcgDiv.style.display = 'none';
            } else {
                middleSquareBtn.classList.remove('active');
                lcgBtn.classList.add('active');
                middleSquareDiv.style.display = 'none';
                lcgDiv.style.display = 'block';
            }
        }
        
        // Middle-Square Method
        function generateMiddleSquare(count) {
            const seed = parseInt(document.getElementById('msSeed').value) || 7182;
            
            if (isNaN(seed)) {
                showNotification('Please enter a valid seed number', 'error');
                return [];
            }
            
            let numbers = [];
            let middleSquareData = [];
            let current = seed;
            let digits = seed.toString().length;
            
            for (let i = 0; i < count; i++) {
                // Square the current number
                let squared = current * current;
                
                // Convert to string and pad with zeros
                let squaredStr = squared.toString();
                const desiredLength = digits * 2;
                while (squaredStr.length < desiredLength) {
                    squaredStr = '0' + squaredStr;
                }
                
                // Calculate position to start taking middle digits
                const startPos = Math.floor((squaredStr.length - digits) / 2);
                const middleDigits = squaredStr.substr(startPos, digits);
                
                // Convert to number
                const nextNumber = parseInt(middleDigits);
                
                // Calculate U_i (first 2 decimal places)
                const middleDigitsStr = middleDigits.toString().padStart(2, '0');
                const firstTwoDigits = middleDigitsStr.length >= 2 ? middleDigitsStr.substring(0, 2) : '00';
                
                // Create U_i value (0.00 to 0.99) from first two digits
                const u_i = parseInt(firstTwoDigits) / 100;
                
                // Generate random number between 0 and 99 (for 00-99)
                const randomNumber = Math.floor(u_i * 100);
                
                // Store number
                numbers.push(randomNumber);
                
                // Store data for display
                middleSquareData.push({
                    i: i,
                    Zi: current,
                    Ui: u_i,
                    randomNum: randomNumber
                });
                
                // Use the next number as seed (or use original if 0)
                current = nextNumber === 0 ? seed + i + 1 : nextNumber;
            }
            
            lastGeneratedNumbers = numbers;
            
            // Display preview
            const preview = document.getElementById('rngPreview');
            let previewHTML = `<strong>Middle-Square Method Results (showing first 10):</strong><br><br>`;
            previewHTML += `<table style="width:100%; font-size:0.9em; border-collapse: collapse;">`;
            previewHTML += `<tr><th style="border:1px solid #ccc; padding:4px;">i</th><th style="border:1px solid #ccc; padding:4px;">Z_i</th><th style="border:1px solid #ccc; padding:4px;">U_i</th><th style="border:1px solid #ccc; padding:4px;">Random #</th></tr>`;
            
            // Show first 10 entries
            const displayCount = Math.min(10, middleSquareData.length);
            for (let i = 0; i < displayCount; i++) {
                const data = middleSquareData[i];
                previewHTML += `<tr>
                    <td style="border:1px solid #ccc; padding:4px;">${data.i}</td>
                    <td style="border:1px solid #ccc; padding:4px;">${data.Zi}</td>
                    <td style="border:1px solid #ccc; padding:4px;">${data.Ui.toFixed(2)}</td>
                    <td style="border:1px solid #ccc; padding:4px;">${String(data.randomNum).padStart(2, '0')}</td>
                </tr>`;
            }
            
            previewHTML += `</table>`;
            
            if (middleSquareData.length > 10) {
                previewHTML += `<p style="margin-top:5px;">... plus ${middleSquareData.length - 10} more entries</p>`;
            }
            
            // Show generated random numbers
            previewHTML += `<br><strong>Generated Random Numbers (00-99):</strong><br>`;
            previewHTML += numbers.slice(0, 20).map(n => String(n).padStart(2, '0')).join(', ') + 
                (numbers.length > 20 ? `... (${numbers.length} total)` : '');
            
            preview.innerHTML = previewHTML;
            
            return numbers;
        }
        
        // Linear Congruential Generator
        function generateLCG(count) {
            const seed = parseInt(document.getElementById('lcgSeed').value) || 7;
            const multiplier = parseInt(document.getElementById('lcgMultiplier').value) || 5;
            const increment = parseInt(document.getElementById('lcgIncrement').value) || 3;
            const modulus = parseInt(document.getElementById('lcgModulus').value) || 16;
            
            if (isNaN(seed) || isNaN(multiplier) || isNaN(increment) || isNaN(modulus)) {
                showNotification('Please enter valid numbers for all parameters', 'error');
                return [];
            }
            
            if (modulus <= 0) {
                showNotification('Modulus must be greater than 0', 'error');
                return [];
            }
            
            let numbers = [];
            let lcgData = [];
            let current = seed;
            
            for (let i = 0; i < count; i++) {
                // Calculate next number using LCG formula: Z_i = (a * Z_{i-1} + c) mod m
                current = (multiplier * current + increment) % modulus;
                
                // Get U_i value between 0 and 1: U_i = Z_i / m
                const u_i = current / modulus;
                
                // Generate random number between 0 and 99 (for 00-99)
                const randomNumber = Math.floor(u_i * 100);
                
                // Store number
                numbers.push(randomNumber);
                
                // Store data for display
                lcgData.push({
                    i: i,
                    Zi: current,
                    Ui: u_i,
                    randomNum: randomNumber
                });
            }
            
            lastGeneratedNumbers = numbers;
            
            // Display preview
            const preview = document.getElementById('rngPreview');
            let previewHTML = `<strong>LCG Results (showing first 10):</strong><br><br>`;
            previewHTML += `<table style="width:100%; font-size:0.9em; border-collapse: collapse;">`;
            previewHTML += `<tr><th style="border:1px solid #ccc; padding:4px;">i</th><th style="border:1px solid #ccc; padding:4px;">Z_i</th><th style="border:1px solid #ccc; padding:4px;">U_i</th><th style="border:1px solid #ccc; padding:4px;">Random #</th></tr>`;
            
            // Show first 10 entries
            const displayCount = Math.min(10, lcgData.length);
            for (let i = 0; i < displayCount; i++) {
                const data = lcgData[i];
                previewHTML += `<tr>
                    <td style="border:1px solid #ccc; padding:4px;">${data.i}</td>
                    <td style="border:1px solid #ccc; padding:4px;">${data.Zi}</td>
                    <td style="border:1px solid #ccc; padding:4px;">${data.Ui.toFixed(4)}</td>
                    <td style="border:1px solid #ccc; padding:4px;">${String(data.randomNum).padStart(2, '0')}</td>
                </tr>`;
            }
            
            previewHTML += `</table>`;
            
            if (lcgData.length > 10) {
                previewHTML += `<p style="margin-top:5px;">... plus ${lcgData.length - 10} more entries</p>`;
            }
            
            // Show generated random numbers
            previewHTML += `<br><strong>Generated Random Numbers (00-99):</strong><br>`;
            previewHTML += numbers.slice(0, 20).map(n => String(n).padStart(2, '0')).join(', ') + 
                (numbers.length > 20 ? `... (${numbers.length} total)` : '');
            
            preview.innerHTML = previewHTML;
            
            return numbers;
        }
        
        // Generate RNG Numbers
        function generateRNGNumbers(type) {
            let count;
            
            if (currentRNGMethod === 'middleSquare') {
                count = parseInt(document.getElementById('msCount').value) || 30;
            } else {
                count = parseInt(document.getElementById('lcgCount').value) || 30;
            }
            
            let numbers = [];
            
            if (currentRNGMethod === 'middleSquare') {
                numbers = generateMiddleSquare(count);
            } else {
                numbers = generateLCG(count);
            }
            
            if (numbers.length === 0) {
                return;
            }
            
            // Update the appropriate textarea
            const numbersString = numbers.map(n => String(n).padStart(2, '0')).join(', ');
            
            if (type === 'arrival') {
                document.getElementById('arrivalRandoms').value = numbersString;
                showNotification(`Generated ${numbers.length} arrival random numbers using ${currentRNGMethod === 'middleSquare' ? 'Middle-Square' : 'LCG'} method.`, 'success');
            } else if (type === 'able') {
                document.getElementById('ableRandoms').value = numbersString;
                showNotification(`Generated ${numbers.length} Able service random numbers using ${currentRNGMethod === 'middleSquare' ? 'Middle-Square' : 'LCG'} method.`, 'success');
            } else if (type === 'baker') {
                document.getElementById('bakerRandoms').value = numbersString;
                showNotification(`Generated ${numbers.length} Baker service random numbers using ${currentRNGMethod === 'middleSquare' ? 'Middle-Square' : 'LCG'} method.`, 'success');
            }
        }
        
        function selectSimulationMode(mode) {
            simulationMode = mode;
            
            // Update UI
            document.getElementById('modeTime').classList.remove('selected');
            document.getElementById('modeCustomers').classList.remove('selected');
            document.getElementById('mode' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('selected');
            
            // Show/hide appropriate input
            if (mode === 'time') {
                document.getElementById('timeInputGroup').style.display = 'block';
                document.getElementById('customerInputGroup').style.display = 'none';
                document.getElementById('modeDescription').textContent = 'Simulation will run for the specified time (minutes)';
            } else {
                document.getElementById('timeInputGroup').style.display = 'none';
                document.getElementById('customerInputGroup').style.display = 'block';
                document.getElementById('modeDescription').textContent = 'Simulation will run until the specified number of customers are served';
            }
            
            updateRandomNumberHints();
        }
        
        function updateRandomNumberHints() {
            if (simulationMode === 'time') {
                // For time-based, we don't know exact number of customers
                document.getElementById('arrivalHint').textContent = 'Enter enough random numbers for expected arrivals (e.g., 30-40 numbers for 60 minutes)';
                document.getElementById('ableHint').textContent = 'Enter enough random numbers for expected Able services';
                document.getElementById('bakerHint').textContent = 'Enter enough random numbers for expected Baker services';
            } else {
                const numCustomers = parseInt(document.getElementById('numCustomers').value) || 20;
                document.getElementById('arrivalHint').textContent = `Need ${numCustomers - 1} arrival random numbers (one less than customers)`;
                document.getElementById('ableHint').textContent = `Need ${numCustomers} Able service random numbers`;
                document.getElementById('bakerHint').textContent = `Need ${numCustomers} Baker service random numbers`;
            }
        }
        
        function selectPriority(server) {
            priorityServer = server;
            
            // Update UI
            document.getElementById('priorityAble').classList.remove('selected');
            document.getElementById('priorityBaker').classList.remove('selected');
            document.getElementById('priorityRandom').classList.remove('selected');
            
            document.getElementById('priority' + server.charAt(0).toUpperCase() + server.slice(1)).classList.add('selected');
        }
        
        // Arrival distribution functions
        function addArrivalRow(time = '', prob = '') {
            const tbody = document.getElementById('arrivalDistributionBody');
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><input type="number" class="arrival-time" value="${time}" min="1" max="100" placeholder="e.g., 1" style="width: 90%; padding: 8px;"></td>
                <td><input type="number" class="arrival-prob" value="${prob}" min="0" max="1" step="0.001" placeholder="0.25" style="width: 90%; padding: 8px;"></td>
                <td class="arrival-cumulative">0.0000</td>
                <td class="arrival-range">01-01</td>
                <td><button onclick="this.parentElement.parentElement.remove(); updateArrivalDistribution()" style="padding: 5px 10px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">Remove</button></td>
            `;
            tbody.appendChild(row);
            
            // Add event listeners to inputs
            row.querySelector('.arrival-time').addEventListener('input', updateArrivalDistribution);
            row.querySelector('.arrival-prob').addEventListener('input', updateArrivalDistribution);
            
            updateArrivalDistribution();
        }
        
        function removeLastArrivalRow() {
            const tbody = document.getElementById('arrivalDistributionBody');
            if (tbody.children.length > 0) {
                tbody.lastElementChild.remove();
                updateArrivalDistribution();
            }
        }
        
        // Able distribution functions
        function addAbleRow(time = '', prob = '') {
            const tbody = document.getElementById('ableDistributionBody');
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><input type="number" class="able-time" value="${time}" min="1" max="100" placeholder="e.g., 2" style="width: 90%; padding: 8px;"></td>
                <td><input type="number" class="able-prob" value="${prob}" min="0" max="1" step="0.001" placeholder="0.30" style="width: 90%; padding: 8px;"></td>
                <td class="able-cumulative">0.0000</td>
                <td class="able-range">01-01</td>
                <td><button onclick="this.parentElement.parentElement.remove(); updateAbleDistribution()" style="padding: 5px 10px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">Remove</button></td>
            `;
            tbody.appendChild(row);
            
            // Add event listeners to inputs
            row.querySelector('.able-time').addEventListener('input', updateAbleDistribution);
            row.querySelector('.able-prob').addEventListener('input', updateAbleDistribution);
            
            updateAbleDistribution();
        }
        
        function removeLastAbleRow() {
            const tbody = document.getElementById('ableDistributionBody');
            if (tbody.children.length > 0) {
                tbody.lastElementChild.remove();
                updateAbleDistribution();
            }
        }
        
        // Baker distribution functions
        function addBakerRow(time = '', prob = '') {
            const tbody = document.getElementById('bakerDistributionBody');
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><input type="number" class="baker-time" value="${time}" min="1" max="100" placeholder="e.g., 3" style="width: 90%; padding: 8px;"></td>
                <td><input type="number" class="baker-prob" value="${prob}" min="0" max="1" step="0.001" placeholder="0.35" style="width: 90%; padding: 8px;"></td>
                <td class="baker-cumulative">0.0000</td>
                <td class="baker-range">01-01</td>
                <td><button onclick="this.parentElement.parentElement.remove(); updateBakerDistribution()" style="padding: 5px 10px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">Remove</button></td>
            `;
            tbody.appendChild(row);
            
            // Add event listeners to inputs
            row.querySelector('.baker-time').addEventListener('input', updateBakerDistribution);
            row.querySelector('.baker-prob').addEventListener('input', updateBakerDistribution);
            
            updateBakerDistribution();
        }
        
        function removeLastBakerRow() {
            const tbody = document.getElementById('bakerDistributionBody');
            if (tbody.children.length > 0) {
                tbody.lastElementChild.remove();
                updateBakerDistribution();
            }
        }
        
        // Update distribution tables
        function updateDistribution(tableId, distributionArray, probClass, timeClass, cumClass, rangeClass, totalId) {
            const rows = document.getElementById(tableId).getElementsByTagName('tbody')[0].children;
            let totalProb = 0;
            let cumulative = 0;
            
            distributionArray.length = 0; // Clear array
            
            // Collect data
            const probabilities = [];
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                const time = parseFloat(row.querySelector('.' + timeClass).value) || 0;
                const prob = parseFloat(row.querySelector('.' + probClass).value) || 0;
                
                if (time > 0 && prob > 0) {
                    probabilities.push({time: time, prob: prob});
                    totalProb += prob;
                }
            }
            
            if (probabilities.length === 0) {
                const totalElement = document.getElementById(totalId);
                totalElement.textContent = `Total Probability: 0.0000 (Should be 1.0000)`;
                totalElement.className = 'probability-status probability-error';
                return;
            }
            
            // Calculate ranges (simple proportional allocation)
            let currentRangeStart = 1;
            let slotTotal = 0;
            
            for (let i = 0; i < probabilities.length; i++) {
                const {time, prob} = probabilities[i];
                
                // Calculate how many slots (1-100) this probability gets
                const slots = Math.round(prob * 100);
                slotTotal += slots;
                
                // Handle last item to ensure total is 100
                let endRange;
                if (i === probabilities.length - 1) {
                    endRange = 100; // Last item goes to 100
                } else {
                    endRange = currentRangeStart + slots - 1;
                }
                
                // Handle wrap-around: if endRange > 100, show as 00
                let displayEndRange = endRange;
                if (endRange === 100) {
                    displayEndRange = 0; // Show as 00 for display
                }
                
                cumulative += prob;
                
                // Store in distribution array
                distributionArray.push({
                    time: time,
                    probability: prob,
                    cumulative: cumulative,
                    startRange: currentRangeStart,
                    endRange: endRange,
                    displayEndRange: displayEndRange
                });
                
                // Update display
                if (rows[i]) {
                    rows[i].querySelector('.' + cumClass).textContent = cumulative.toFixed(4);
                    rows[i].querySelector('.' + rangeClass).textContent = 
                        `${String(currentRangeStart).padStart(2, '0')}–${String(displayEndRange).padStart(2, '0')}`;
                }
                
                currentRangeStart = endRange + 1;
                if (currentRangeStart > 100) currentRangeStart = 1;
            }
            
            // Update total probability display
            const totalElement = document.getElementById(totalId);
            const tolerance = 0.001; // Allow small floating point errors
            
            if (Math.abs(totalProb - 1.0) < tolerance) {
                totalElement.textContent = `Total Probability: ${totalProb.toFixed(4)} ✓`;
                totalElement.className = 'probability-status probability-ok';
            } else {
                totalElement.textContent = `Total Probability: ${totalProb.toFixed(4)} (Should be 1.0000)`;
                totalElement.className = 'probability-status probability-error';
            }
        }
        
        function updateArrivalDistribution() {
            updateDistribution('arrivalDistributionTable', arrivalDistribution, 
                'arrival-prob', 'arrival-time', 'arrival-cumulative', 'arrival-range', 'arrivalProbTotal');
        }
        
        function updateAbleDistribution() {
            updateDistribution('ableDistributionTable', ableDistribution, 
                'able-prob', 'able-time', 'able-cumulative', 'able-range', 'ableProbTotal');
        }
        
        function updateBakerDistribution() {
            updateDistribution('bakerDistributionTable', bakerDistribution, 
                'baker-prob', 'baker-time', 'baker-cumulative', 'baker-range', 'bakerProbTotal');
        }
        
        // Random number generation functions
        function generateArrivalRandoms() {
            let randomNumbers = [];
            let count = 30; // Default for time-based
            
            if (simulationMode === 'customers') {
                const numCustomers = parseInt(document.getElementById('numCustomers').value) || 20;
                count = numCustomers - 1;
            }
            
            for (let i = 0; i < count; i++) {
                randomNumbers.push(Math.floor(Math.random() * 100));
            }
            
            document.getElementById('arrivalRandoms').value = randomNumbers.map(n => String(n).padStart(2, '0')).join(', ');
            showNotification(`Generated ${count} random arrival numbers (00-99)`, 'success');
        }
        
        function generateAbleRandoms() {
            let randomNumbers = [];
            let count = 30; // Default for time-based
            
            if (simulationMode === 'customers') {
                const numCustomers = parseInt(document.getElementById('numCustomers').value) || 20;
                count = numCustomers;
            }
            
            for (let i = 0; i < count; i++) {
                randomNumbers.push(Math.floor(Math.random() * 100));
            }
            
            document.getElementById('ableRandoms').value = randomNumbers.map(n => String(n).padStart(2, '0')).join(', ');
            showNotification(`Generated ${count} Able service random numbers (00-99)`, 'success');
        }
        
        function generateBakerRandoms() {
            let randomNumbers = [];
            let count = 30; // Default for time-based
            
            if (simulationMode === 'customers') {
                const numCustomers = parseInt(document.getElementById('numCustomers').value) || 20;
                count = numCustomers;
            }
            
            for (let i = 0; i < count; i++) {
                randomNumbers.push(Math.floor(Math.random() * 100));
            }
            
            document.getElementById('bakerRandoms').value = randomNumbers.map(n => String(n).padStart(2, '0')).join(', ');
            showNotification(`Generated ${count} Baker service random numbers (00-99)`, 'success');
        }
        
        // Load example from PDF
        function loadExampleFromPDF() {
            // Clear existing rows
            document.getElementById('arrivalDistributionBody').innerHTML = '';
            document.getElementById('ableDistributionBody').innerHTML = '';
            document.getElementById('bakerDistributionBody').innerHTML = '';
            
            // Load arrival distribution from PDF
            const arrivalData = [
                {time: 1, prob: 0.25},
                {time: 2, prob: 0.40},
                {time: 3, prob: 0.20},
                {time: 4, prob: 0.15}
            ];
            
            arrivalData.forEach(data => {
                addArrivalRow(data.time, data.prob);
            });
            
            // Load Able distribution from PDF
            const ableData = [
                {time: 2, prob: 0.30},
                {time: 3, prob: 0.28},
                {time: 4, prob: 0.25},
                {time: 5, prob: 0.17}
            ];
            
            ableData.forEach(data => {
                addAbleRow(data.time, data.prob);
            });
            
            // Load Baker distribution from PDF
            const bakerData = [
                {time: 3, prob: 0.35},
                {time: 4, prob: 0.25},
                {time: 5, prob: 0.20},
                {time: 6, prob: 0.20}
            ];
            
            bakerData.forEach(data => {
                addBakerRow(data.time, data.prob);
            });
            
            // Load random numbers from PDF example
            const arrivalRandoms = [26, 98, 90, 26, 42, 74, 80, 68, 22, 48, 90, 17, 89, 93, 46, 68, 6, 17, 83];
            const ableRandoms = [95, 21, 51, 92, 89, 38, 13, 61, 50, 49, 39, 53, 88, 86, 36, 24, 53, 74, 17, 33];
            const bakerRandoms = [25, 36, 52, 45, 73, 77, 65, 85, 23, 76, 25, 15, 11, 98, 67, 42, 35, 86, 43, 57];
            
            document.getElementById('arrivalRandoms').value = arrivalRandoms.map(n => String(n).padStart(2, '0')).join(', ');
            document.getElementById('ableRandoms').value = ableRandoms.map(n => String(n).padStart(2, '0')).join(', ');
            document.getElementById('bakerRandoms').value = bakerRandoms.map(n => String(n).padStart(2, '0')).join(', ');
            
            // Set to time-based simulation (as in PDF)
            selectSimulationMode('time');
            document.getElementById('simulationTime').value = 60;
            document.getElementById('numCustomers').value = 20;
            
            // Update distributions
            updateArrivalDistribution();
            updateAbleDistribution();
            updateBakerDistribution();
            
            showNotification('Loaded PDF example successfully! This simulates a call center with 2 servers (Able & Baker) for 60 minutes.', 'success');
        }
        
        // Utility functions
        function normalizeRandomNumber(num) {
            // Parse the number
            const n = parseFloat(num);
            if (isNaN(n)) return 1;
            
            // Handle numbers 0-99 (including 00 = 0)
            // In this simulation, we're using 00-99 where 100 means 00
            if (n >= 0 && n <= 99) {
                return n === 0 ? 100 : n; // Map 0 to 100 (which represents 00)
            }
            
            // Handle numbers > 100
            if (n > 100) {
                // Take last two digits
                const lastTwo = n % 100;
                return lastTwo === 0 ? 100 : lastTwo;
            }
            
            return 1; // Default
        }
        
        function mapRandomToTime(randomDigit, distribution) {
            const randomValue = normalizeRandomNumber(randomDigit);
            
            if (distribution.length === 0) {
                showNotification('Please define distribution first', 'error');
                return 1;
            }
            
            // Find which range the random number falls into
            for (let dist of distribution) {
                const start = dist.startRange;
                const end = dist.endRange;
                
                if (randomValue >= start && randomValue <= end) {
                    return dist.time;
                }
            }
            
            // If not found, use last distribution
            return distribution[distribution.length - 1].time;
        }
        
        // Show export buttons
        function showExportButtons() {
            const exportButtons = document.getElementById('exportButtons');
            exportButtons.style.display = 'flex';
        }
        
        // Hide export buttons
        function hideExportButtons() {
            const exportButtons = document.getElementById('exportButtons');
            exportButtons.style.display = 'none';
        }
        
        // Show notification
        function showNotification(message, type) {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                border-radius: 5px;
                color: white;
                font-weight: 600;
                z-index: 1000;
                animation: slideIn 0.3s ease-out;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;
            
            if (type === 'success') {
                notification.style.backgroundColor = '#2ecc71';
            } else if (type === 'error') {
                notification.style.backgroundColor = '#e74c3c';
            } else {
                notification.style.backgroundColor = '#3498db';
            }
            
            notification.textContent = message;
            document.body.appendChild(notification);
            
            // Remove notification after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
            
            // Add CSS for animations
            if (!document.querySelector('#notification-styles')) {
                const style = document.createElement('style');
                style.id = 'notification-styles';
                style.textContent = `
                    @keyframes slideIn {
                        from {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                        to {
                            transform: translateX(0);
                            opacity: 1;
                        }
                    }
                    @keyframes slideOut {
                        from {
                            transform: translateX(0);
                            opacity: 1;
                        }
                        to {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        // Run auto-exports after simulation
        function runAutoExports(simulationType) {
            const autoExcel = document.getElementById('autoExcel').checked;
            const autoPDF = document.getElementById('autoPDF').checked;
            
            if (autoExcel) {
                setTimeout(() => {
                    exportToExcel();
                }, 1000);
            }
            
            if (autoPDF) {
                setTimeout(() => {
                    generatePDFReport();
                }, autoExcel ? 2000 : 1000);
            }
        }
        
        // Main simulation function
        function runMultiServerSimulation() {
            let simulationTimeLimit, targetCustomers;
            
            if (simulationMode === 'time') {
                simulationTimeLimit = parseInt(document.getElementById('simulationTime').value);
                if (!simulationTimeLimit || simulationTimeLimit < 1) {
                    showNotification('Please enter a valid simulation time (minimum 1 minute)', 'error');
                    return;
                }
                targetCustomers = Infinity; // No customer limit for time-based
            } else {
                targetCustomers = parseInt(document.getElementById('numCustomers').value);
                if (!targetCustomers || targetCustomers < 1) {
                    showNotification('Please enter a valid number of customers (minimum 1)', 'error');
                    return;
                }
                simulationTimeLimit = Infinity; // No time limit for customer-based
            }
            
            // Validate distributions
            if (arrivalDistribution.length === 0) {
                showNotification('Please define arrival time distribution', 'error');
                return;
            }
            
            if (ableDistribution.length === 0) {
                showNotification('Please define Able service time distribution', 'error');
                return;
            }
            
            if (bakerDistribution.length === 0) {
                showNotification('Please define Baker service time distribution', 'error');
                return;
            }
            
            // Check if probabilities sum to 1
            const arrivalTotal = arrivalDistribution.reduce((sum, dist) => sum + dist.probability, 0);
            const ableTotal = ableDistribution.reduce((sum, dist) => sum + dist.probability, 0);
            const bakerTotal = bakerDistribution.reduce((sum, dist) => sum + dist.probability, 0);
            const tolerance = 0.001;
            
            if (Math.abs(arrivalTotal - 1.0) > tolerance) {
                showNotification('Arrival probabilities must sum to exactly 1.0000', 'error');
                return;
            }
            
            if (Math.abs(ableTotal - 1.0) > tolerance) {
                showNotification('Able service probabilities must sum to exactly 1.0000', 'error');
                return;
            }
            
            if (Math.abs(bakerTotal - 1.0) > tolerance) {
                showNotification('Baker service probabilities must sum to exactly 1.0000', 'error');
                return;
            }
            
            // Parse random numbers
            const arrivalInput = document.getElementById('arrivalRandoms').value.trim();
            const ableInput = document.getElementById('ableRandoms').value.trim();
            const bakerInput = document.getElementById('bakerRandoms').value.trim();
            
            if (!arrivalInput || !ableInput || !bakerInput) {
                showNotification('Please provide all random numbers (arrival, Able service, Baker service)', 'error');
                return;
            }
            
            // Parse and normalize random numbers
            const arrivalRandoms = arrivalInput.split(',')
                .map(r => r.trim())
                .filter(r => r !== '')
                .map(normalizeRandomNumber);
            
            const ableRandoms = ableInput.split(',')
                .map(r => r.trim())
                .filter(r => r !== '')
                .map(normalizeRandomNumber);
            
            const bakerRandoms = bakerInput.split(',')
                .map(r => r.trim())
                .filter(r => r !== '')
                .map(normalizeRandomNumber);
            
            // For customer-based simulation, check if we have enough random numbers
            if (simulationMode === 'customers') {
                if (arrivalRandoms.length < targetCustomers - 1) {
                    showNotification(`Need ${targetCustomers - 1} arrival random numbers, got ${arrivalRandoms.length}`, 'error');
                    return;
                }
                
                if (ableRandoms.length < targetCustomers) {
                    showNotification(`Need ${targetCustomers} Able service random numbers, got ${ableRandoms.length}`, 'error');
                    return;
                }
                
                if (bakerRandoms.length < targetCustomers) {
                    showNotification(`Need ${targetCustomers} Baker service random numbers, got ${bakerRandoms.length}`, 'error');
                    return;
                }
            }
            
            // Run simulation
            const simulation = simulateMultiServerQueue(
                arrivalRandoms,
                ableRandoms,
                bakerRandoms,
                simulationTimeLimit,
                targetCustomers
            );
            
            // Store simulation results for export
            simulationResults = simulation;
            
            // Display results
            displayMultiServerResults(simulation);
            
            // Show export buttons
            showExportButtons();
            
            // Show success notification
            showNotification(`Simulated ${simulation.totalCustomers} customers successfully!`, 'success');
            
            // Run auto-exports if enabled
            setTimeout(() => {
                runAutoExports('Simulation completed');
            }, 500);
        }
        
        // Simulation function
        function simulateMultiServerQueue(arrivalRandoms, ableRandoms, bakerRandoms, timeLimit, customerLimit) {
            let customers = [];
            let totalWaitTime = 0;
            let totalSystemTime = 0;
            let ableIdleTime = 0;
            let bakerIdleTime = 0;
            let ableBusyTime = 0;
            let bakerBusyTime = 0;
            let numWaiting = 0;
            
            let clock = 0;
            let ableFreeTime = 0; // Time when Able becomes free
            let bakerFreeTime = 0; // Time when Baker becomes free
            let customerCount = 0;
            let ablePrevFreeTime = 0;
            let bakerPrevFreeTime = 0;
            
            // Determine which limit we're using
            const useTimeLimit = timeLimit !== Infinity;
            const useCustomerLimit = customerLimit !== Infinity;
            
            // Get random number indices
            let arrivalIndex = 0;
            let ableIndex = 0;
            let bakerIndex = 0;
            
            // Simulation loop
            while (true) {
                // Check stopping conditions
                if (useTimeLimit && clock >= timeLimit) break;
                if (useCustomerLimit && customerCount >= customerLimit) break;
                if (arrivalIndex >= arrivalRandoms.length && customerCount > 0) break;
                if (ableIndex >= ableRandoms.length || bakerIndex >= bakerRandoms.length) break;
                
                // Calculate arrival time
                let arrivalTime;
                if (customerCount === 0) {
                    arrivalTime = 0;
                    ablePrevFreeTime = 0;
                    bakerPrevFreeTime = 0;
                } else {
                    // Map random number to interarrival time
                    const interarrivalTime = mapRandomToTime(arrivalRandoms[arrivalIndex], arrivalDistribution);
                    arrivalTime = customers[customerCount-1].arrivalTime + interarrivalTime;
                    arrivalIndex++;
                }
                
                // Update clock to arrival time
                clock = arrivalTime;
                if (useTimeLimit && clock > timeLimit) {
                    // Customer arrived after time limit, don't process
                    break;
                }
                
                // Calculate idle times for servers before this arrival
                if (arrivalTime > ablePrevFreeTime) {
                    ableIdleTime += (arrivalTime - ablePrevFreeTime);
                }
                if (arrivalTime > bakerPrevFreeTime) {
                    bakerIdleTime += (arrivalTime - bakerPrevFreeTime);
                }
                
                // Determine which server to use based on priority rule
                let serverAssigned = '';
                let timeServiceBegins = 0;
                let serviceTime = 0;
                let timeServiceEnds = 0;
                
                // Check server availability
                const ableAvailable = arrivalTime >= ableFreeTime;
                const bakerAvailable = arrivalTime >= bakerFreeTime;
                
                if (ableAvailable && bakerAvailable) {
                    // Both servers are idle, apply priority rule
                    if (priorityServer === 'able') {
                        serverAssigned = 'Able';
                    } else if (priorityServer === 'baker') {
                        serverAssigned = 'Baker';
                    } else {
                        // Random assignment
                        serverAssigned = Math.random() < 0.5 ? 'Able' : 'Baker';
                    }
                } else if (ableAvailable) {
                    serverAssigned = 'Able';
                } else if (bakerAvailable) {
                    serverAssigned = 'Baker';
                } else {
                    // Both servers are busy, customer waits for first available
                    if (ableFreeTime <= bakerFreeTime) {
                        serverAssigned = 'Able';
                    } else {
                        serverAssigned = 'Baker';
                    }
                }
                
                // Get service time based on assigned server
                if (serverAssigned === 'Able') {
                    serviceTime = mapRandomToTime(ableRandoms[ableIndex], ableDistribution);
                    ableIndex++;
                } else {
                    serviceTime = mapRandomToTime(bakerRandoms[bakerIndex], bakerDistribution);
                    bakerIndex++;
                }
                
                // Set service parameters
                if (serverAssigned === 'Able') {
                    timeServiceBegins = Math.max(arrivalTime, ableFreeTime);
                    timeServiceEnds = timeServiceBegins + serviceTime;
                    ablePrevFreeTime = ableFreeTime;
                    ableFreeTime = timeServiceEnds;
                    ableBusyTime += serviceTime;
                } else {
                    timeServiceBegins = Math.max(arrivalTime, bakerFreeTime);
                    timeServiceEnds = timeServiceBegins + serviceTime;
                    bakerPrevFreeTime = bakerFreeTime;
                    bakerFreeTime = timeServiceEnds;
                    bakerBusyTime += serviceTime;
                }
                
                // Calculate waiting and system times
                const waitTime = timeServiceBegins - arrivalTime;
                const systemTime = timeServiceEnds - arrivalTime;
                const timeInQueue = waitTime; // Time in queue is the same as wait time
                
                if (waitTime > 0) {
                    numWaiting++;
                }
                
                totalWaitTime += waitTime;
                totalSystemTime += systemTime;
                
                // Store customer data
                customers.push({
                    customer: customerCount + 1,
                    arrivalRandom: customerCount === 0 ? '-' : arrivalRandoms[arrivalIndex - 1],
                    interarrivalTime: customerCount === 0 ? '-' : mapRandomToTime(arrivalRandoms[arrivalIndex - 1], arrivalDistribution),
                    arrivalTime: arrivalTime,
                    
                    // Able columns
                    ableServiceRandom: serverAssigned === 'Able' ? ableRandoms[ableIndex - 1] : ableRandoms[ableIndex],
                    ableServiceTime: serverAssigned === 'Able' ? serviceTime : mapRandomToTime(ableRandoms[ableIndex], ableDistribution),
                    ableServiceBegins: serverAssigned === 'Able' ? timeServiceBegins : '',
                    ableServiceEnds: serverAssigned === 'Able' ? timeServiceEnds : '',
                    
                    // Baker columns
                    bakerServiceRandom: serverAssigned === 'Baker' ? bakerRandoms[bakerIndex - 1] : bakerRandoms[bakerIndex],
                    bakerServiceTime: serverAssigned === 'Baker' ? serviceTime : mapRandomToTime(bakerRandoms[bakerIndex], bakerDistribution),
                    bakerServiceBegins: serverAssigned === 'Baker' ? timeServiceBegins : '',
                    bakerServiceEnds: serverAssigned === 'Baker' ? timeServiceEnds : '',
                    
                    // Common columns
                    server: serverAssigned,
                    timeInQueue: timeInQueue,
                    systemTime: systemTime,
                    waitTime: waitTime
                });
                
                customerCount++;
                clock = Math.max(clock, timeServiceEnds);
            }
            
            // Calculate final idle times (idle at the end of simulation)
            const simulationEndTime = useTimeLimit ? Math.min(clock, timeLimit) : clock;
            if (ableFreeTime < simulationEndTime) ableIdleTime += (simulationEndTime - ableFreeTime);
            if (bakerFreeTime < simulationEndTime) bakerIdleTime += (simulationEndTime - bakerFreeTime);
            
            // Calculate server utilization
            const ableUtilization = simulationEndTime > 0 ? ableBusyTime / simulationEndTime : 0;
            const bakerUtilization = simulationEndTime > 0 ? bakerBusyTime / simulationEndTime : 0;
            
            return {
                customers: customers,
                totalWaitTime: totalWaitTime,
                totalSystemTime: totalSystemTime,
                ableIdleTime: ableIdleTime,
                bakerIdleTime: bakerIdleTime,
                ableBusyTime: ableBusyTime,
                bakerBusyTime: bakerBusyTime,
                ableUtilization: ableUtilization,
                bakerUtilization: bakerUtilization,
                numWaiting: numWaiting,
                totalCustomers: customers.length,
                simulationEndTime: simulationEndTime,
                simulationMode: simulationMode,
                timeLimit: timeLimit,
                customerLimit: customerLimit
            };
        }
        
        // Display results function
        function displayMultiServerResults(simulation) {
            const { 
                customers, 
                totalWaitTime, 
                totalSystemTime, 
                ableIdleTime, 
                bakerIdleTime,
                ableBusyTime,
                bakerBusyTime,
                ableUtilization,
                bakerUtilization,
                numWaiting, 
                totalCustomers, 
                simulationEndTime,
                simulationMode,
                timeLimit,
                customerLimit
            } = simulation;
            
            // Calculate performance measures
            const avgWaitTime = totalCustomers > 0 ? totalWaitTime / totalCustomers : 0;
            const avgSystemTime = totalCustomers > 0 ? totalSystemTime / totalCustomers : 0;
            const probWait = totalCustomers > 0 ? numWaiting / totalCustomers : 0;
            const totalInterarrivalTimes = customers.slice(1).reduce((sum, cust) => sum + cust.interarrivalTime, 0);
            const avgInterarrivalTime = customers.length > 1 ? totalInterarrivalTimes / (customers.length - 1) : 0;
            
            // Determine simulation mode description
            let modeDescription = '';
            if (simulationMode === 'time') {
                modeDescription = `Time-based simulation: ${timeLimit} minutes`;
            } else {
                modeDescription = `Customer-based simulation: ${customerLimit} customers`;
            }
            
            // Create distribution tables
            let distributionHTML = `
                <h3 class="results-header">Input Distributions</h3>
                
                <h4>Arrival Time Distribution</h4>
                <table class="distribution-table">
                    <thead>
                        <tr>
                            <th>Time Between Arrivals</th>
                            <th>Probability</th>
                            <th>Cumulative</th>
                            <th>Random Number Range</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            arrivalDistribution.forEach(dist => {
                distributionHTML += `
                    <tr>
                        <td>${dist.time} minutes</td>
                        <td>${dist.probability.toFixed(4)}</td>
                        <td>${dist.cumulative.toFixed(4)}</td>
                        <td>${String(dist.startRange).padStart(2, '0')}-${String(dist.displayEndRange).padStart(2, '0')}</td>
                    </tr>
                `;
            });
            
            distributionHTML += `
                    </tbody>
                </table>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-top: 30px;">
                    <div>
                        <h4>Able Service Distribution</h4>
                        <table class="distribution-table">
                            <thead>
                                <tr>
                                    <th>Service Time</th>
                                    <th>Probability</th>
                                    <th>Cumulative</th>
                                    <th>Random Number Range</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            ableDistribution.forEach(dist => {
                distributionHTML += `
                    <tr>
                        <td>${dist.time} minutes</td>
                        <td>${dist.probability.toFixed(4)}</td>
                        <td>${dist.cumulative.toFixed(4)}</td>
                        <td>${String(dist.startRange).padStart(2, '0')}-${String(dist.displayEndRange).padStart(2, '0')}</td>
                    </tr>
                `;
            });
            
            distributionHTML += `
                            </tbody>
                        </table>
                    </div>
                    
                    <div>
                        <h4>Baker Service Distribution</h4>
                        <table class="distribution-table">
                            <thead>
                                <tr>
                                    <th>Service Time</th>
                                    <th>Probability</th>
                                    <th>Cumulative</th>
                                    <th>Random Number Range</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            bakerDistribution.forEach(dist => {
                distributionHTML += `
                    <tr>
                        <td>${dist.time} minutes</td>
                        <td>${dist.probability.toFixed(4)}</td>
                        <td>${dist.cumulative.toFixed(4)}</td>
                        <td>${String(dist.startRange).padStart(2, '0')}-${String(dist.displayEndRange).padStart(2, '0')}</td>
                    </tr>
                `;
            });
            
            distributionHTML += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            
            // Create simulation table with both Able and Baker columns
            let tableHTML = '';
            if (customers.length > 0) {
                tableHTML = `
                    <h3 class="results-header">Simulation Table - ${modeDescription}</h3>
                    <div style="margin-bottom: 15px; padding: 10px; background-color: #e8f4ff; border-radius: 5px;">
                        <strong>Simulation Results:</strong> ${totalCustomers} customers served in ${simulationEndTime.toFixed(1)} minutes
                    </div>
                    <div class="simulation-table-container">
                        <table class="simulation-table">
                            <thead>
                                <tr>
                                    <th rowspan="2">Customer</th>
                                    <th rowspan="2">Arrival Random</th>
                                    <th rowspan="2">Interarrival Time</th>
                                    <th rowspan="2">Arrival Time</th>
                                    <th colspan="4" class="server-header">Able (Server 1)</th>
                                    <th colspan="4" class="server-header">Baker (Server 2)</th>
                                    <th rowspan="2">Server Assigned</th>
                                    <th rowspan="2">Wait Time</th>
                                    <th rowspan="2">System Time</th>
                                </tr>
                                <tr>
                                    <!-- Able sub-headers -->
                                    <th class="server-header">Service Random</th>
                                    <th class="server-header">Service Time</th>
                                    <th class="server-header">Service Begins</th>
                                    <th class="server-header">Service Ends</th>
                                    
                                    <!-- Baker sub-headers -->
                                    <th class="server-header">Service Random</th>
                                    <th class="server-header">Service Time</th>
                                    <th class="server-header">Service Begins</th>
                                    <th class="server-header">Service Ends</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                // Track previous service end times for idle time calculation
                let prevAbleEnd = 0;
                let prevBakerEnd = 0;
                
                customers.forEach((customer, index) => {
                    const serverClass = customer.server === 'Able' ? 'highlight-able' : 'highlight-baker';
                    
                    // Format data - show blank if server is not working on this customer
                    const ableServiceBegins = customer.ableServiceBegins !== '' ? customer.ableServiceBegins.toFixed(1) : '<span class="blank-data">-</span>';
                    const ableServiceEnds = customer.ableServiceEnds !== '' ? customer.ableServiceEnds.toFixed(1) : '<span class="blank-data">-</span>';
                    const bakerServiceBegins = customer.bakerServiceBegins !== '' ? customer.bakerServiceBegins.toFixed(1) : '<span class="blank-data">-</span>';
                    const bakerServiceEnds = customer.bakerServiceEnds !== '' ? customer.bakerServiceEnds.toFixed(1) : '<span class="blank-data">-</span>';
                    
                    tableHTML += `
                        <tr class="${serverClass}">
                            <td>${customer.customer}</td>
                            <td>${String(customer.arrivalRandom).padStart(2, '0')}</td>
                            <td>${customer.interarrivalTime}</td>
                            <td>${customer.arrivalTime.toFixed(1)}</td>
                            
                            <!-- Able columns -->
                            <td>${String(customer.ableServiceRandom).padStart(2, '0')}</td>
                            <td>${customer.ableServiceTime}</td>
                            <td>${ableServiceBegins}</td>
                            <td>${ableServiceEnds}</td>
                            
                            <!-- Baker columns -->
                            <td>${String(customer.bakerServiceRandom).padStart(2, '0')}</td>
                            <td>${customer.bakerServiceTime}</td>
                            <td>${bakerServiceBegins}</td>
                            <td>${bakerServiceEnds}</td>
                            
                            <!-- Common columns -->
                            <td><strong>${customer.server}</strong></td>
                            <td>${customer.waitTime.toFixed(1)}</td>
                            <td>${customer.systemTime.toFixed(1)}</td>
                        </tr>
                    `;
                });
                
                tableHTML += `
                            <tr style="background-color: #f8f9fa; font-weight: bold;">
                                <td colspan="15"><strong>Totals / Averages</strong></td>
                                <td><strong>${totalWaitTime.toFixed(1)}</strong><br>(${avgWaitTime.toFixed(2)} avg)</td>
                                <td><strong>${totalSystemTime.toFixed(1)}</strong><br>(${avgSystemTime.toFixed(2)} avg)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                `;
            } else {
                tableHTML = `
                    <div style="margin: 30px 0; padding: 30px; text-align: center; background-color: #f8f9fa; border-radius: 10px;">
                        <h4>No Customers Served</h4>
                        <p>The simulation ended before any customers could be served.</p>
                        <p>This might be because the simulation time was too short or random numbers were insufficient.</p>
                    </div>
                `;
            }
            
            // Create server utilization cards
            const serverHTML = totalCustomers > 0 ? `
                <h3 class="results-header">Server Performance</h3>
                <div class="server-utilization">
                    <div class="server-card able">
                        <h4>Able (Server 1)</h4>
                        <div class="utilization">${(ableUtilization * 100).toFixed(1)}%</div>
                        <p>Busy: ${ableBusyTime.toFixed(1)} min</p>
                        <p>Idle: ${ableIdleTime.toFixed(1)} min</p>
                        <p>Utilization: ${(ableUtilization * 100).toFixed(1)}%</p>
                    </div>
                    
                    <div class="server-card baker">
                        <h4>Baker (Server 2)</h4>
                        <div class="utilization">${(bakerUtilization * 100).toFixed(1)}%</div>
                        <p>Busy: ${bakerBusyTime.toFixed(1)} min</p>
                        <p>Idle: ${bakerIdleTime.toFixed(1)} min</p>
                        <p>Utilization: ${(bakerUtilization * 100).toFixed(1)}%</p>
                    </div>
                </div>
            ` : '';
            
            // Create summary cards
            const summaryHTML = totalCustomers > 0 ? `
                <h3 class="results-header">System Performance Summary</h3>
                <div class="summary-cards">
                    <div class="summary-card">
                        <h4>Average Waiting Time</h4>
                        <div class="value">${avgWaitTime.toFixed(2)}</div>
                        <div class="unit">minutes</div>
                    </div>
                    <div class="summary-card">
                        <h4>Probability of Waiting</h4>
                        <div class="value">${(probWait * 100).toFixed(1)}%</div>
                        <div class="unit">${numWaiting}/${totalCustomers} customers</div>
                    </div>
                    <div class="summary-card">
                        <h4>Average Time in System</h4>
                        <div class="value">${avgSystemTime.toFixed(2)}</div>
                        <div class="unit">minutes</div>
                    </div>
                    <div class="summary-card">
                        <h4>Average Interarrival Time</h4>
                        <div class="value">${avgInterarrivalTime.toFixed(2)}</div>
                        <div class="unit">minutes</div>
                    </div>
                    <div class="summary-card">
                        <h4>Customers Served</h4>
                        <div class="value">${totalCustomers}</div>
                        <div class="unit">in ${simulationEndTime.toFixed(1)} min</div>
                    </div>
                    <div class="summary-card">
                        <h4>Priority Rule</h4>
                        <div class="value">${priorityServer.charAt(0).toUpperCase() + priorityServer.slice(1)}</div>
                        <div class="unit">when both idle</div>
                    </div>
                </div>
            ` : '';
            
            // Combine everything
            document.getElementById('resultsSection').innerHTML = `
                ${distributionHTML}
                ${serverHTML}
                ${summaryHTML}
                ${tableHTML}
                
                <div style="margin-top: 40px; padding: 20px; background-color: #f8f9fa; border-radius: 8px;">
                    <h4>Simulation Analysis</h4>
                    <p><strong>Simulation Mode:</strong> ${modeDescription}</p>
                    ${totalCustomers > 0 ? `
                    <p>From this simulation:</p>
                    <ul style="margin-top: 10px;">
                        <li>Able was busy <strong>${(ableUtilization * 100).toFixed(1)}%</strong> of the time</li>
                        <li>Baker was busy <strong>${(bakerUtilization * 100).toFixed(1)}%</strong> of the time</li>
                        <li><strong>${(probWait * 100).toFixed(1)}%</strong> of customers had to wait</li>
                        <li>Average waiting time was <strong>${avgWaitTime.toFixed(2)} minute(s)</strong></li>
                    </ul>
                    ` : '<p>No customers were served in this simulation.</p>'}
                </div>
            `;
        }
        
        // Generate PDF Report
        function generatePDFReport() {
            if (!simulationResults) {
                showNotification('Please run a simulation first', 'error');
                return;
            }
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('p', 'mm', 'a4');
            
            // PDF metadata
            doc.setProperties({
                title: 'Multi-Server Queue Simulation Report',
                subject: 'Two-Server Call Center Simulation Results',
                author: 'Queue Simulation Tool',
                keywords: 'queue simulation, multi-server, Able, Baker, call center',
                creator: 'Queue Simulation Tool'
            });
            
            let yPos = 20;
            const margin = 20;
            const pageWidth = doc.internal.pageSize.width;
            const pageHeight = doc.internal.pageSize.height;
            
            // Title
            doc.setFontSize(20);
            doc.setTextColor(40, 40, 40);
            doc.text('Multi-Server Queue Simulation Report', pageWidth / 2, yPos, { align: 'center' });
            yPos += 10;
            
            doc.setFontSize(12);
            doc.setTextColor(100, 100, 100);
            doc.text(`Two-Server Call Center (Able & Baker)`, pageWidth / 2, yPos, { align: 'center' });
            yPos += 7;
            doc.text(`Generated: ${new Date().toLocaleString()}`, pageWidth / 2, yPos, { align: 'center' });
            yPos += 15;
            
            // Section 1: Simulation Parameters
            doc.setFontSize(16);
            doc.setTextColor(50, 50, 50);
            doc.text('1. Simulation Parameters', margin, yPos);
            yPos += 10;
            
            doc.setFontSize(11);
            doc.setTextColor(80, 80, 80);
            
            // Simulation mode
            const modeDescription = simulationResults.simulationMode === 'time' 
                ? `Time-based: ${simulationResults.timeLimit} minutes` 
                : `Customer-based: ${simulationResults.customerLimit} customers`;
            
            doc.text(`Simulation Mode: ${modeDescription}`, margin + 5, yPos);
            yPos += 7;
            doc.text(`Priority Rule: ${priorityServer.charAt(0).toUpperCase() + priorityServer.slice(1)} gets priority when both idle`, margin + 5, yPos);
            yPos += 7;
            doc.text(`Total Customers: ${simulationResults.totalCustomers}`, margin + 5, yPos);
            yPos += 7;
            doc.text(`Simulation End Time: ${simulationResults.simulationEndTime.toFixed(1)} minutes`, margin + 5, yPos);
            yPos += 15;
            
            // Check if we need a new page
            if (yPos > pageHeight - 100) {
                doc.addPage();
                yPos = margin;
            }
            
            // Section 2: Performance Summary
            doc.setFontSize(16);
            doc.setTextColor(50, 50, 50);
            doc.text('2. Performance Summary', margin, yPos);
            yPos += 10;
            
            doc.setFontSize(11);
            
            // Calculate performance measures
            const avgWaitTime = simulationResults.totalCustomers > 0 ? simulationResults.totalWaitTime / simulationResults.totalCustomers : 0;
            const avgSystemTime = simulationResults.totalCustomers > 0 ? simulationResults.totalSystemTime / simulationResults.totalCustomers : 0;
            const probWait = simulationResults.totalCustomers > 0 ? simulationResults.numWaiting / simulationResults.totalCustomers : 0;
            
            // Server utilization
            const ableUtilization = simulationResults.simulationEndTime > 0 ? simulationResults.ableBusyTime / simulationResults.simulationEndTime : 0;
            const bakerUtilization = simulationResults.simulationEndTime > 0 ? simulationResults.bakerBusyTime / simulationResults.simulationEndTime : 0;
            
            // Create summary table
            const summaryData = [
                ['Metric', 'Value'],
                ['Average Waiting Time', `${avgWaitTime.toFixed(2)} minutes`],
                ['Probability of Waiting', `${(probWait * 100).toFixed(1)}%`],
                ['Average Time in System', `${avgSystemTime.toFixed(2)} minutes`],
                ['Able Utilization', `${(ableUtilization * 100).toFixed(1)}%`],
                ['Baker Utilization', `${(bakerUtilization * 100).toFixed(1)}%`],
                ['Able Idle Time', `${simulationResults.ableIdleTime.toFixed(1)} minutes`],
                ['Baker Idle Time', `${simulationResults.bakerIdleTime.toFixed(1)} minutes`],
                ['Customers Waiting', `${simulationResults.numWaiting}/${simulationResults.totalCustomers}`]
            ];
            
            // Draw table
            doc.autoTable({
                startY: yPos,
                head: [summaryData[0]],
                body: summaryData.slice(1),
                theme: 'grid',
                headStyles: { fillColor: [41, 128, 185], textColor: 255, fontStyle: 'bold' },
                margin: { left: margin, right: margin }
            });
            
            yPos = doc.lastAutoTable.finalY + 15;
            
            // Check if we need a new page
            if (yPos > pageHeight - 100) {
                doc.addPage();
                yPos = margin;
            }
            
            // Section 3: Distribution Summary
            doc.setFontSize(16);
            doc.setTextColor(50, 50, 50);
            doc.text('3. Input Distributions', margin, yPos);
            yPos += 10;
            
            doc.setFontSize(11);
            doc.text('Arrival Time Distribution:', margin + 5, yPos);
            yPos += 7;
            
            // Arrival distribution table
            let arrivalDistData = [['Time', 'Probability', 'Range']];
            arrivalDistribution.forEach(dist => {
                arrivalDistData.push([
                    `${dist.time} min`,
                    dist.probability.toFixed(4),
                    `${String(dist.startRange).padStart(2, '0')}-${String(dist.displayEndRange).padStart(2, '0')}`
                ]);
            });
            
            doc.autoTable({
                startY: yPos,
                head: [arrivalDistData[0]],
                body: arrivalDistData.slice(1),
                theme: 'grid',
                headStyles: { fillColor: [46, 204, 113], textColor: 255, fontStyle: 'bold' },
                margin: { left: margin, right: margin }
            });
            
            yPos = doc.lastAutoTable.finalY + 15;
            
            // Check if we need a new page
            if (yPos > pageHeight - 100) {
                doc.addPage();
                yPos = margin;
            }
            
            // Service distributions side by side
            doc.text('Service Time Distributions:', margin + 5, yPos);
            yPos += 7;
            
            // Able distribution
            let ableDistData = [['Time', 'Probability', 'Range']];
            ableDistribution.forEach(dist => {
                ableDistData.push([
                    `${dist.time} min`,
                    dist.probability.toFixed(4),
                    `${String(dist.startRange).padStart(2, '0')}-${String(dist.displayEndRange).padStart(2, '0')}`
                ]);
            });
            
            doc.autoTable({
                startY: yPos,
                head: [['Able (Server 1)']],
                body: ableDistData.slice(1),
                theme: 'grid',
                headStyles: { fillColor: [52, 152, 219], textColor: 255, fontStyle: 'bold' },
                margin: { left: margin, right: pageWidth/2 - 10 }
            });
            
            // Baker distribution
            let bakerDistData = [['Time', 'Probability', 'Range']];
            bakerDistribution.forEach(dist => {
                bakerDistData.push([
                    `${dist.time} min`,
                    dist.probability.toFixed(4),
                    `${String(dist.startRange).padStart(2, '0')}-${String(dist.displayEndRange).padStart(2, '0')}`
                ]);
            });
            
            doc.autoTable({
                startY: yPos,
                head: [['Baker (Server 2)']],
                body: bakerDistData.slice(1),
                theme: 'grid',
                headStyles: { fillColor: [231, 76, 60], textColor: 255, fontStyle: 'bold' },
                margin: { left: pageWidth/2 + 10, right: margin }
            });
            
            yPos = doc.lastAutoTable.finalY + 15;
            
            // Check if we need a new page
            if (yPos > pageHeight - 50) {
                doc.addPage();
                yPos = margin;
            }
            
            // Section 4: Sample Customers
            if (simulationResults.customers.length > 0) {
                doc.setFontSize(16);
                doc.setTextColor(50, 50, 50);
                doc.text('4. Sample Customer Data (First 10)', margin, yPos);
                yPos += 10;
                
                doc.setFontSize(11);
                
                // Create sample customer table
                let sampleCustomers = [['Cust', 'Arrival', 'Server', 'Wait', 'System']];
                const sampleCount = Math.min(10, simulationResults.customers.length);
                
                for (let i = 0; i < sampleCount; i++) {
                    const cust = simulationResults.customers[i];
                    sampleCustomers.push([
                        cust.customer,
                        cust.arrivalTime.toFixed(1),
                        cust.server,
                        cust.waitTime.toFixed(1),
                        cust.systemTime.toFixed(1)
                    ]);
                }
                
                doc.autoTable({
                    startY: yPos,
                    head: [sampleCustomers[0]],
                    body: sampleCustomers.slice(1),
                    theme: 'grid',
                    headStyles: { fillColor: [155, 89, 182], textColor: 255, fontStyle: 'bold' },
                    margin: { left: margin, right: margin }
                });
                
                yPos = doc.lastAutoTable.finalY + 10;
                
                if (simulationResults.customers.length > 10) {
                    doc.text(`... and ${simulationResults.customers.length - 10} more customers`, margin + 5, yPos);
                    yPos += 7;
                }
            }
            
            // Conclusion
            doc.text('', margin + 5, yPos);
            yPos += 10;
            
            doc.setFontSize(12);
            doc.setTextColor(50, 50, 50);
            doc.text('Analysis:', margin + 5, yPos);
            yPos += 7;
            
            doc.setFontSize(11);
            doc.setTextColor(80, 80, 80);
            
            const conclusion = `This simulation of a two-server call center shows that Able was busy ${(ableUtilization * 100).toFixed(1)}% of the time, 
            while Baker was busy ${(bakerUtilization * 100).toFixed(1)}% of the time. ${(probWait * 100).toFixed(1)}% of customers had to wait, 
            with an average waiting time of ${avgWaitTime.toFixed(2)} minutes.`;
            
            const splitConclusion = doc.splitTextToSize(conclusion, pageWidth - 2 * margin - 10);
            doc.text(splitConclusion, margin + 5, yPos);
            yPos += splitConclusion.length * 5 + 10;
            
            // Footer
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFontSize(9);
                doc.setTextColor(150, 150, 150);
                doc.text(`Page ${i} of ${pageCount}`, pageWidth / 2, pageHeight - 10, { align: 'center' });
                doc.text(`Multi-Server Queue Simulation Report - ${new Date().toLocaleDateString()}`, pageWidth - margin, pageHeight - 10, { align: 'right' });
            }
            
            // Save the PDF
            const fileName = `Multi_Server_Queue_Report_${new Date().toISOString().slice(0,10)}_${new Date().getTime()}.pdf`;
            doc.save(fileName);
            
            showNotification(`PDF report "${fileName}" has been downloaded`, 'success');
        }
        
        // Export to Excel
        function exportToExcel() {
            if (!simulationResults) {
                showNotification('Please run a simulation first', 'error');
                return;
            }
            
            // Create workbook
            const wb = XLSX.utils.book_new();
            
            // Add Summary Sheet
            const summaryData = [
                ['Multi-Server Queue Simulation Results'],
                ['Two-Server Call Center (Able & Baker)'],
                ['Generated: ' + new Date().toLocaleString()],
                ['Simulation Mode: ' + (simulationResults.simulationMode === 'time' ? 'Time-based' : 'Customer-based')],
                [''],
                ['Performance Summary']
            ];
            
            // Calculate performance measures
            const avgWaitTime = simulationResults.totalCustomers > 0 ? simulationResults.totalWaitTime / simulationResults.totalCustomers : 0;
            const avgSystemTime = simulationResults.totalCustomers > 0 ? simulationResults.totalSystemTime / simulationResults.totalCustomers : 0;
            const probWait = simulationResults.totalCustomers > 0 ? simulationResults.numWaiting / simulationResults.totalCustomers : 0;
            const ableUtilization = simulationResults.simulationEndTime > 0 ? simulationResults.ableBusyTime / simulationResults.simulationEndTime : 0;
            const bakerUtilization = simulationResults.simulationEndTime > 0 ? simulationResults.bakerBusyTime / simulationResults.simulationEndTime : 0;
            
            summaryData.push(['Metric', 'Value', '']);
            summaryData.push(['Total Customers', simulationResults.totalCustomers, '']);
            summaryData.push(['Simulation End Time', simulationResults.simulationEndTime.toFixed(1) + ' minutes', '']);
            summaryData.push(['Average Waiting Time', avgWaitTime.toFixed(2) + ' minutes', '']);
            summaryData.push(['Probability of Waiting', (probWait * 100).toFixed(1) + '%', '']);
            summaryData.push(['Average Time in System', avgSystemTime.toFixed(2) + ' minutes', '']);
            summaryData.push(['', '', '']);
            summaryData.push(['Server Performance', 'Able', 'Baker']);
            summaryData.push(['Utilization', (ableUtilization * 100).toFixed(1) + '%', (bakerUtilization * 100).toFixed(1) + '%']);
            summaryData.push(['Busy Time', simulationResults.ableBusyTime.toFixed(1) + ' min', simulationResults.bakerBusyTime.toFixed(1) + ' min']);
            summaryData.push(['Idle Time', simulationResults.ableIdleTime.toFixed(1) + ' min', simulationResults.bakerIdleTime.toFixed(1) + ' min']);
            summaryData.push(['', '', '']);
            summaryData.push(['Priority Rule', priorityServer.charAt(0).toUpperCase() + priorityServer.slice(1) + ' gets priority when both idle', '']);
            
            const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(wb, summaryWs, "Summary");
            
            // Add Distribution Sheets
            const arrivalDistData = [
                ['Arrival Time Distribution'],
                ['Time (min)', 'Probability', 'Cumulative', 'Range']
            ];
            
            arrivalDistribution.forEach(dist => {
                arrivalDistData.push([
                    dist.time,
                    dist.probability.toFixed(4),
                    dist.cumulative.toFixed(4),
                    `${String(dist.startRange).padStart(2, '0')}-${String(dist.displayEndRange).padStart(2, '0')}`
                ]);
            });
            
            const arrivalDistWs = XLSX.utils.aoa_to_sheet(arrivalDistData);
            XLSX.utils.book_append_sheet(wb, arrivalDistWs, "Arrival Distribution");
            
            // Able Distribution
            const ableDistData = [
                ['Able Service Time Distribution'],
                ['Time (min)', 'Probability', 'Cumulative', 'Range']
            ];
            
            ableDistribution.forEach(dist => {
                ableDistData.push([
                    dist.time,
                    dist.probability.toFixed(4),
                    dist.cumulative.toFixed(4),
                    `${String(dist.startRange).padStart(2, '0')}-${String(dist.displayEndRange).padStart(2, '0')}`
                ]);
            });
            
            const ableDistWs = XLSX.utils.aoa_to_sheet(ableDistData);
            XLSX.utils.book_append_sheet(wb, ableDistWs, "Able Distribution");
            
            // Baker Distribution
            const bakerDistData = [
                ['Baker Service Time Distribution'],
                ['Time (min)', 'Probability', 'Cumulative', 'Range']
            ];
            
            bakerDistribution.forEach(dist => {
                bakerDistData.push([
                    dist.time,
                    dist.probability.toFixed(4),
                    dist.cumulative.toFixed(4),
                    `${String(dist.startRange).padStart(2, '0')}-${String(dist.displayEndRange).padStart(2, '0')}`
                ]);
            });
            
            const bakerDistWs = XLSX.utils.aoa_to_sheet(bakerDistData);
            XLSX.utils.book_append_sheet(wb, bakerDistWs, "Baker Distribution");
            
            // Add Customer Data Sheet
            if (simulationResults.customers.length > 0) {
                const customerData = [
                    ['Customer Simulation Data'],
                    ['Customer', 'Arrival Random', 'Interarrival Time', 'Arrival Time', 
                     'Able Service Random', 'Able Service Time', 'Able Service Begins', 'Able Service Ends',
                     'Baker Service Random', 'Baker Service Time', 'Baker Service Begins', 'Baker Service Ends',
                     'Server Assigned', 'Wait Time', 'System Time']
                ];
                
                simulationResults.customers.forEach(cust => {
                    customerData.push([
                        cust.customer,
                        cust.arrivalRandom,
                        cust.interarrivalTime,
                        cust.arrivalTime.toFixed(1),
                        cust.ableServiceRandom,
                        cust.ableServiceTime,
                        cust.ableServiceBegins !== '' ? cust.ableServiceBegins.toFixed(1) : '',
                        cust.ableServiceEnds !== '' ? cust.ableServiceEnds.toFixed(1) : '',
                        cust.bakerServiceRandom,
                        cust.bakerServiceTime,
                        cust.bakerServiceBegins !== '' ? cust.bakerServiceBegins.toFixed(1) : '',
                        cust.bakerServiceEnds !== '' ? cust.bakerServiceEnds.toFixed(1) : '',
                        cust.server,
                        cust.waitTime.toFixed(1),
                        cust.systemTime.toFixed(1)
                    ]);
                });
                
                const customerWs = XLSX.utils.aoa_to_sheet(customerData);
                XLSX.utils.book_append_sheet(wb, customerWs, "Customer Data");
            }
            
            // Add Random Numbers Sheet
            const randomNumbersData = [
                ['Random Numbers Used in Simulation'],
                [''],
                ['Arrival Random Numbers:'],
                [document.getElementById('arrivalRandoms').value],
                [''],
                ['Able Service Random Numbers:'],
                [document.getElementById('ableRandoms').value],
                [''],
                ['Baker Service Random Numbers:'],
                [document.getElementById('bakerRandoms').value]
            ];
            
            const randomNumbersWs = XLSX.utils.aoa_to_sheet(randomNumbersData);
            XLSX.utils.book_append_sheet(wb, randomNumbersWs, "Random Numbers");
            
            // Generate and download Excel file
            const fileName = `Multi_Server_Queue_Simulation_${new Date().toISOString().slice(0,10)}_${new Date().getTime()}.xlsx`;
            XLSX.writeFile(wb, fileName);
            
            showNotification(`Excel file "${fileName}" has been downloaded`, 'success');
        }
    </script>
</body>
</html>