<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Single Server Queue - Queuing Simulation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* ============================================
           GLOBAL RESET & BASE STYLES
           ============================================ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #2c3e50);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: #333;
            line-height: 1.6;
        }

        /* ============================================
           CONTAINER & LAYOUT
           ============================================ */
        .container {
            width: 100%;
            max-width: 1800px;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            margin: 0 auto;
        }

        .content {
            background: white;
            padding: 30px;
            border-radius: 10px;
        }

        /* ============================================
           HEADER STYLES
           ============================================ */
        header {
            background: linear-gradient(135deg, #2c3e50, #4a6491);
            color: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 25px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: white;
        }

        h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 2rem;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 5px;
            color: rgba(255, 255, 255, 0.9);
        }

        .author {
            font-size: 0.9rem;
            opacity: 0.7;
            font-style: italic;
            color: rgba(255, 255, 255, 0.7);
        }

        /* ============================================
           BUTTON STYLES
           ============================================ */
        /* Back Button */
        .back-btn {
            padding: 10px 20px;
            background-color: #7f8c8d;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            margin-bottom: 25px;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .back-btn:hover {
            background-color: #6c7b7d;
        }

        /* Export Buttons */
        .export-buttons {
            display: flex;
            gap: 15px;
            margin: 25px 0;
            flex-wrap: wrap;
        }

        .export-btn {
            padding: 12px 25px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 180px;
        }

        .export-btn.pdf {
            background-color: #e74c3c;
        }

        .export-btn.pdf:hover {
            background-color: #c0392b;
        }

        .export-btn.excel {
            background-color: #2ecc71;
        }

        .export-btn.excel:hover {
            background-color: #27ae60;
        }

        .export-btn.load-pdf {
            background-color: #9b59b6;
        }

        .export-btn.load-pdf:hover {
            background-color: #8e44ad;
        }

        .export-btn:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        /* Action Buttons */
        .add-row-btn, .remove-row-btn {
            padding: 10px 18px;
            margin: 8px 5px 8px 0;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .add-row-btn {
            background-color: #2ecc71;
            color: white;
        }

        .add-row-btn:hover {
            background-color: #27ae60;
        }

        .remove-row-btn {
            background-color: #e74c3c;
            color: white;
        }

        .remove-row-btn:hover {
            background-color: #c0392b;
        }

        .option-btn {
            padding: 12px 20px;
            border: 2px solid #3498db;
            background-color: white;
            color: #3498db;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            min-width: 200px;
        }

        .option-btn:hover, .option-btn.active {
            background-color: #3498db;
            color: white;
        }

        .simulate-btn {
            padding: 15px 40px;
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1rem;
            margin: 30px 0;
            transition: all 0.3s;
            display: block;
            margin-left: auto;
            margin-right: auto;
            width: 100%;
        }

        .simulate-btn:hover {
            background: linear-gradient(135deg, #27ae60, #219653);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(46, 204, 113, 0.3);
        }

        /* ============================================
           INPUT & FORM STYLES
           ============================================ */
        .input-section {
            margin: 30px 0;
            padding: 25px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border-left: 5px solid #3498db;
        }

        .input-group {
            margin: 20px 0;
        }

        .input-field {
            display: flex;
            flex-direction: column;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #34495e;
        }

        input[type="number"], 
        input[type="text"], 
        select, 
        textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }

        input:focus, 
        select:focus, 
        textarea:focus {
            outline: none;
            border-color: #4a6fa5;
            box-shadow: 0 0 0 2px rgba(74, 111, 165, 0.2);
        }

        .random-numbers-input {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
            font-family: 'Courier New', monospace;
            resize: vertical;
        }

        .input-hint {
            font-size: 0.85rem;
            color: #666;
            margin-top: 5px;
            font-style: italic;
        }

        /* ============================================
           SIMULATION LIMIT OPTIONS
           ============================================ */
        .limit-options {
            display: flex;
            gap: 20px;
            margin-top: 15px;
        }

        .limit-option {
            flex: 1;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.3s;
        }

        .limit-option:hover {
            border-color: #3498db;
            background-color: #f0f8ff;
        }

        .limit-option.selected {
            border-color: #2ecc71;
            background-color: #f0fff4;
        }

        .limit-input {
            margin-top: 10px;
            display: none;
        }

        .limit-input.active {
            display: block;
        }

        /* ============================================
           TABLE STYLES
           ============================================ */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 0.9rem;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: center;
        }

        th {
            background-color: #f2f6fc;
            font-weight: 600;
            color: #2c3e50;
        }

        .distribution-table {
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            margin: 20px 0;
            width: 100%;
        }

        .distribution-table th {
            background-color: #2c3e50;
            color: white;
            padding: 14px;
        }

        .distribution-table td {
            padding: 12px;
            border: 1px solid #e1e1e1;
        }

        .simulation-table-container {
            overflow-x: auto;
            margin: 30px 0;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            padding: 15px;
        }

        .simulation-table {
            width: 100%;
            min-width: 1400px;
            font-size: 0.85rem;
            border-collapse: collapse;
        }

        .simulation-table th {
            background-color: #2c3e50;
            color: white;
            padding: 12px 8px;
            position: sticky;
            top: 0;
            font-weight: 600;
        }

        .simulation-table td {
            padding: 10px 6px;
            border-bottom: 1px solid #eee;
            text-align: center;
        }

        .simulation-table tr:hover {
            background-color: #f5f9ff;
        }

        /* ============================================
           RNG CONFIGURATION STYLES
           ============================================ */
        .rng-configuration {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .rng-method {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 2px solid #3498db;
        }

        .rng-method h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .rng-method h4 i {
            color: #3498db;
        }

        .rng-parameters {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .rng-param-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .rng-param-group label {
            min-width: 120px;
            margin-bottom: 0;
        }

        .rng-param-group input {
            flex: 1;
            padding: 8px;
        }

        .rng-preview {
            margin-top: 15px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 150px;
            overflow-y: auto;
        }

        .method-selector {
            display: flex;
            gap: 15px;
            margin: 15px 0;
        }

        .method-btn {
            padding: 12px 20px;
            background-color: #f8f9fa;
            border: 2px solid #3498db;
            color: #3498db;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            flex: 1;
        }

        .method-btn:hover, .method-btn.active {
            background-color: #3498db;
            color: white;
        }

        /* ============================================
           RESULT & SUMMARY STYLES
           ============================================ */
        .results-section {
            margin-top: 40px;
        }

        .results-header {
            color: #2c3e50;
            margin: 30px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }

        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }

        .summary-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.08);
            text-align: center;
            border-top: 5px solid #3498db;
        }

        .summary-card h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .summary-card .value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #2c3e50;
            margin: 10px 0;
        }

        .summary-card .unit {
            color: #7f8c8d;
            font-size: 0.85rem;
        }

        /* ============================================
           STATUS INDICATORS
           ============================================ */
        .probability-status {
            font-weight: bold;
            margin-left: 20px;
            padding: 8px 15px;
            border-radius: 5px;
            display: inline-block;
        }

        .probability-error {
            background-color: #ffeaea;
            color: #e74c3c;
        }

        .probability-ok {
            background-color: #e8f7ef;
            color: #27ae60;
        }

        /* ============================================
           SPECIAL ELEMENTS
           ============================================ */
        .warning {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 12px;
            border-radius: 5px;
            margin: 15px 0;
            font-size: 0.9rem;
        }

        .mapping-example {
            background-color: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 15px 0;
            font-size: 0.9rem;
        }

        .mapping-example strong {
            color: #2c3e50;
        }

        /* ============================================
           PRINT STYLES
           ============================================ */
        @media print {
            .back-btn, .option-buttons, .export-buttons, .add-row-btn, 
            .remove-row-btn, .simulate-btn, .footer, .input-section,
            .probability-status, .limit-options, .limit-input,
            .rng-configuration, .method-selector, .rng-preview,
            .random-numbers-input, textarea, #arrivalRandoms, 
            #serviceRandoms, .input-group[class*="random"],
            .random-input-area, .warning {
                display: none !important;
            }
            
            .container {
                max-width: 100% !important;
                padding: 0 !important;
                margin: 0 !important;
                box-shadow: none !important;
                background-color: white !important;
            }
            
            body {
                background: white !important;
                padding: 0 !important;
                min-height: auto !important;
                display: block !important;
            }
            
            .content {
                padding: 10px !important;
                box-shadow: none !important;
                border-radius: 0 !important;
            }
            
            .simulation-table-container {
                overflow: visible !important;
                box-shadow: none !important;
                padding: 0 !important;
                margin: 10px 0 !important;
            }
            
            .simulation-table {
                font-size: 0.7rem !important;
                min-width: auto !important;
                width: 100% !important;
            }
            
            .distribution-table th, .simulation-table th {
                color: black !important;
                background-color: #f0f0f0 !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
                font-size: 0.8rem !important;
                padding: 6px 4px !important;
            }
            
            .distribution-table td, .simulation-table td {
                padding: 5px 3px !important;
                font-size: 0.7rem !important;
            }
            
            .summary-card {
                break-inside: avoid;
                box-shadow: none !important;
                border: 1px solid #ddd !important;
                margin: 5px 0 !important;
                padding: 10px !important;
            }
            
            .summary-card .value {
                font-size: 1.4rem !important;
            }
            
            .summary-cards {
                display: grid !important;
                grid-template-columns: repeat(3, 1fr) !important;
                gap: 10px !important;
                margin: 15px 0 !important;
            }
            
            header {
                background: white !important;
                color: black !important;
                box-shadow: none !important;
                border: 1px solid #ddd !important;
                padding: 15px !important;
                margin-bottom: 15px !important;
            }
            
            h1 {
                color: black !important;
                font-size: 1.8rem !important;
            }
            
            h2, h3, h4 {
                font-size: 1.2rem !important;
                margin: 10px 0 !important;
            }
            
            .subtitle, .author {
                color: #666 !important;
            }
            
            .results-header {
                margin: 15px 0 10px 0 !important;
                padding-bottom: 5px !important;
                font-size: 1.1rem !important;
            }
            
            /* Ensure tables don't break across pages */
            table {
                page-break-inside: avoid !important;
            }
            
            tr {
                page-break-inside: avoid !important;
                page-break-after: auto !important;
            }
            
            /* Hide all input sections in print */
            div[class*="input"]:not(.input-section):not(.results-section) {
                display: none !important;
            }
        }

        /* ============================================
           FOOTER
           ============================================ */
        .footer {
            margin-top: 40px;
            text-align: center;
            color: #7f8c8d;
            font-size: 0.9rem;
            padding: 20px;
            border-top: 1px solid #eee;
        }

        /* ============================================
           RESPONSIVE DESIGN
           ============================================ */
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 15px;
            }
            
            .content {
                padding: 15px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .export-buttons, .option-buttons, .method-selector {
                flex-direction: column;
            }
            
            .export-btn, .option-btn, .method-btn {
                min-width: auto;
                width: 100%;
                justify-content: center;
            }
            
            .limit-options, .rng-configuration {
                flex-direction: column;
            }
            
            .input-group {
                flex-direction: column;
                align-items: flex-start;
            }
            
            input, select, textarea {
                width: 100%;
            }
            
            .rng-param-group {
                flex-direction: column;
                align-items: flex-start;
            }
        }

        @media (max-width: 480px) {
            .distribution-table {
                font-size: 0.8rem;
            }
            
            .distribution-table th, 
            .distribution-table td {
                padding: 8px 6px;
            }
            
            .simulation-table {
                font-size: 0.7rem;
            }
        }

        /* ============================================
           OPTION BUTTONS CONTAINER
           ============================================ */
        .option-buttons {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Single Server Queue Simulation</h1>
        </header>
        
        <div class="content">
            <button class="back-btn" onclick="window.location.href='index.html'">
                <i class="fas fa-arrow-left"></i> Back to Models
            </button>
            
            <h2>Single Server Queue Simulation</h2>
            
            <div class="input-section">
                <h3>Simulation Parameters</h3>
                
                <div class="limit-options">
                    <div class="limit-option selected" onclick="selectLimitOption('customer')">
                        <h4>Customer Limit</h4>
                        <p>Simulate until reaching a specific number of customers</p>
                        <div class="limit-input active" id="customerLimitInput">
                            <div class="input-group">
                                <label for="numCustomers">Number of Customers to Simulate:</label>
                                <input type="number" id="numCustomers" min="5" max="1000" value="20">
                            </div>
                        </div>
                    </div>
                    
                    <div class="limit-option" onclick="selectLimitOption('time')">
                        <h4>Time Limit</h4>
                        <p>Simulate until reaching a specific time limit</p>
                        <div class="limit-input" id="timeLimitInput">
                            <div class="input-group">
                                <label for="timeLimit">Simulation Time Limit (minutes):</label>
                                <input type="number" id="timeLimit" min="10" max="10000" value="100">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="input-section">
                <h3>Interarrival Time Distribution</h3>
                <p>Define time between arrivals and their probabilities (Total must equal 1.0000):</p>
                
                <table class="distribution-table" id="arrivalDistributionTable">
                    <thead>
                        <tr>
                            <th>Time Between Arrivals (minutes)</th>
                            <th>Probability</th>
                            <th>Cumulative Probability</th>
                            <th>Random-Digit Assignment (01-100)</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody id="arrivalDistributionBody">
                        <!-- Rows will be added here -->
                    </tbody>
                </table>
                
                <div>
                    <button class="add-row-btn" onclick="addArrivalRow()">+ Add Arrival Time</button>
                    <button class="remove-row-btn" onclick="removeLastArrivalRow()">- Remove Last</button>
                    <span id="arrivalProbTotal" class="probability-error">Total Probability: 0.0000 (Should be 1.0000)</span>
                </div>
                
                <div class="mapping-example">
                    <strong>How it works:</strong><br>
                    1. Enter time between arrivals and their probabilities (e.g., 0.125)<br>
                    2. System calculates cumulative probability<br>
                    3. Each probability gets: probability × 100 random numbers<br>
                    4. Random digits start from 01 (not 00)<br>
                    5. Example: Probability = 0.10 → gets 10 random numbers: 01–10
                </div>
            </div>
            
            <div class="input-section">
                <h3>Service Time Distribution</h3>
                <p>Define service times and their probabilities (Total must equal 1.0000):</p>
                
                <table class="distribution-table" id="serviceDistributionTable">
                    <thead>
                        <tr>
                            <th>Service Time (minutes)</th>
                            <th>Probability</th>
                            <th>Cumulative Probability</th>
                            <th>Random-Digit Assignment (01-100)</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody id="serviceDistributionBody">
                        <!-- Rows will be added here -->
                    </tbody>
                </table>
                
                <div>
                    <button class="add-row-btn" onclick="addServiceRow()">+ Add Service Time</button>
                    <button class="remove-row-btn" onclick="removeLastServiceRow()">- Remove Last</button>
                    <span id="serviceProbTotal" class="probability-error">Total Probability: 0.0000 (Should be 1.0000)</span>
                </div>
            </div>
            
            <div class="input-section">
                <h3>Random Number Generation Configuration</h3>
                
                <div class="method-selector">
                    <button class="method-btn active" onclick="selectRNGMethod('middleSquare')">
                        Middle-Square Method
                    </button>
                    <button class="method-btn" onclick="selectRNGMethod('linearCongruential')">
                        Linear Congruential Generator (LCG)
                    </button>
                </div>
                
                <div class="rng-configuration">
                    <!-- Middle-Square Method -->
                    <div class="rng-method" id="middleSquareMethod">
                        <h4><i class="fas fa-square"></i> Middle-Square Method</h4>
                        <p>Generate pseudorandom numbers using the middle-square algorithm. Squares the seed and takes the middle digits to create U_i values.</p>
                        
                        <div class="rng-parameters">
                            <div class="rng-param-group">
                                <label for="msSeed">Seed (any number):</label>
                                <input type="number" id="msSeed" value="7182" min="1" max="99999999">
                            </div>
                            <div class="rng-param-group">
                                <label for="msCount">Count (how many numbers to generate):</label>
                                <input type="number" id="msCount" value="50" min="10" max="1000">
                            </div>
                        </div>
                        
                        <button class="option-btn" onclick="generateMiddleSquare()">
                            <i class="fas fa-calculator"></i> Generate Middle-Square Numbers
                        </button>
                        
                        <div class="rng-preview" id="msPreview">
                            Generated numbers will appear here...
                        </div>
                    </div>
                    
                    <!-- Linear Congruential Generator -->
                    <div class="rng-method" id="linearCongruentialMethod" style="display: none;">
                        <h4><i class="fas fa-cogs"></i> Linear Congruential Generator</h4>
                        <p>Generate pseudorandom numbers using LCG: Zᵢ = (aZᵢ₋₁ + c) mod m.</p>
                        
                        <div class="rng-parameters">
                            <div class="rng-param-group">
                                <label for="lcgSeed">Seed (Z₀):</label>
                                <input type="number" id="lcgSeed" value="7" min="1" max="1000">
                            </div>
                            <div class="rng-param-group">
                                <label for="lcgMultiplier">Multiplier (a):</label>
                                <input type="number" id="lcgMultiplier" value="5" min="1" max="1000">
                            </div>
                            <div class="rng-param-group">
                                <label for="lcgIncrement">Increment (c):</label>
                                <input type="number" id="lcgIncrement" value="3" min="0" max="1000">
                            </div>
                            <div class="rng-param-group">
                                <label for="lcgModulus">Modulus (m):</label>
                                <input type="number" id="lcgModulus" value="16" min="2" max="10000">
                            </div>
                            <div class="rng-param-group">
                                <label for="lcgCount">Count:</label>
                                <input type="number" id="lcgCount" value="50" min="10" max="1000">
                            </div>
                        </div>
                        
                        <button class="option-btn" onclick="generateLCG()">
                            <i class="fas fa-calculator"></i> Generate LCG Numbers
                        </button>
                        
                        <div class="rng-preview" id="lcgPreview">
                            Generated numbers will appear here...
                        </div>
                    </div>
                </div>
                
                <div class="option-buttons">
                    <button class="option-btn" onclick="useGeneratedForArrival()">
                        <i class="fas fa-sign-in-alt"></i> Use Generated for Arrival
                    </button>
                    <button class="option-btn" onclick="useGeneratedForService()">
                        <i class="fas fa-cog"></i> Use Generated for Service
                    </button>
                </div>
            </div>
            
            <div class="input-section">
                <h3>Random Numbers Input</h3>
                <p>Enter random numbers separated by commas (1-100 range):</p>
                
                <div class="warning">
                    <strong>Note:</strong> Random numbers 1-100 only.
                </div>
                
                <div class="option-buttons">
                    <button class="option-btn" onclick="generateRandomArrival()">
                        <i class="fas fa-random"></i> Generate Random Arrival Numbers
                    </button>
                    <button class="option-btn" onclick="generateRandomService()">
                        <i class="fas fa-random"></i> Generate Random Service Numbers
                    </button>
                </div>
                
                <div class="input-group">
                    <label for="arrivalRandoms">Interarrival Random Numbers:</label>
                    <textarea id="arrivalRandoms" class="random-numbers-input random-input-area" placeholder="Enter comma-separated random numbers, e.g., 84, 10, 74, 53, 17, 79" rows="3"></textarea>
                    <div class="input-hint">Need enough numbers for your simulation</div>
                </div>
                
                <div class="input-group">
                    <label for="serviceRandoms">Service Time Random Numbers:</label>
                    <textarea id="serviceRandoms" class="random-numbers-input random-input-area" placeholder="Enter comma-separated random numbers, e.g., 32, 94, 79, 05, 79, 84" rows="3"></textarea>
                    <div class="input-hint">Need enough numbers for your simulation</div>
                </div>
            </div>
            
            <button class="simulate-btn" onclick="runSingleQueueSimulation()">
                <i class="fas fa-play-circle"></i> Run Single Server Queue Simulation
            </button>
            
            <div class="results-section" id="resultsSection">
                <!-- Results will be inserted here -->
            </div>
        </div>
    </div>
    
    <!-- Add SheetJS library for Excel export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <script>
        // Initialize with example data from PDF
        let arrivalDistribution = [];
        let serviceDistribution = [];
        let currentSimulation = null;
        let simulationLimitType = 'customer'; // 'customer' or 'time'
        let currentRNGMethod = 'middleSquare'; // 'middleSquare' or 'linearCongruential'
        let lastGeneratedNumbers = [];
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadExampleFromPDF();
            generateMiddleSquare(); // Generate initial numbers
        });
        
        function selectRNGMethod(method) {
            currentRNGMethod = method;
            
            // Update UI
            const middleSquareBtn = document.querySelector('.method-btn:first-child');
            const lcgBtn = document.querySelector('.method-btn:last-child');
            const middleSquareDiv = document.getElementById('middleSquareMethod');
            const lcgDiv = document.getElementById('linearCongruentialMethod');
            
            if (method === 'middleSquare') {
                middleSquareBtn.classList.add('active');
                lcgBtn.classList.remove('active');
                middleSquareDiv.style.display = 'block';
                lcgDiv.style.display = 'none';
                
                // Generate middle-square numbers when this method is selected
                setTimeout(() => generateMiddleSquare(), 100);
            } else {
                middleSquareBtn.classList.remove('active');
                lcgBtn.classList.add('active');
                middleSquareDiv.style.display = 'none';
                lcgDiv.style.display = 'block';
            }
        }
        
        function selectLimitOption(type) {
            simulationLimitType = type;
            
            // Update UI
            const customerOption = document.querySelector('.limit-option:first-child');
            const timeOption = document.querySelector('.limit-option:last-child');
            const customerInput = document.getElementById('customerLimitInput');
            const timeInput = document.getElementById('timeLimitInput');
            
            if (type === 'customer') {
                customerOption.classList.add('selected');
                timeOption.classList.remove('selected');
                customerInput.classList.add('active');
                timeInput.classList.remove('active');
            } else {
                customerOption.classList.remove('selected');
                timeOption.classList.add('selected');
                customerInput.classList.remove('active');
                timeInput.classList.add('active');
            }
        }
        
        // Middle-Square Method - SIMPLE: U_i × 100 = random number
        function generateMiddleSquare() {
            const seed = parseInt(document.getElementById('msSeed').value);
            const count = parseInt(document.getElementById('msCount').value);
            
            if (isNaN(seed) || isNaN(count)) {
                showNotification('Please enter valid numbers for all parameters', 'error');
                return;
            }
            
            let numbers = [];
            let middleSquareData = []; // Store data for display
            let current = seed;
            let digits = seed.toString().length;
            
            // Generate the table
            for (let i = 0; i < count; i++) {
                // Square the current number
                let squared = current * current;
                
                // Convert to string and pad with zeros
                let squaredStr = squared.toString();
                const desiredLength = digits * 2;
                while (squaredStr.length < desiredLength) {
                    squaredStr = '0' + squaredStr;
                }
                
                // Calculate position to start taking middle digits
                const startPos = Math.floor((squaredStr.length - digits) / 2);
                const middleDigits = squaredStr.substr(startPos, digits);
                
                // Convert to number
                const nextNumber = parseInt(middleDigits);
                
                // Calculate U_i (first 2 decimal places)
                const middleDigitsStr = middleDigits.toString().padStart(2, '0');
                const firstTwoDigits = middleDigitsStr.length >= 2 ? middleDigitsStr.substring(0, 2) : '00';
                
                // Create U_i value (0.00 to 0.99) from first two digits
                const u_i = parseInt(firstTwoDigits) / 100;
                
                // Store data for display
                middleSquareData.push({
                    i: i,
                    Zi: current,
                    Ui: u_i,
                    ZiSquared: squared
                });
                
                // Generate random number: U_i × 100 = 00-99, +1 = 01-100
                const randomNumber = Math.floor(u_i * 100) + 1;
                
                // Ensure number is between 1-100
                numbers.push(Math.max(1, Math.min(100, randomNumber)));
                
                // Use the next number as seed (or use original if 0)
                current = nextNumber === 0 ? seed + i + 1 : nextNumber;
            }
            
            lastGeneratedNumbers = numbers;
            
            // Display preview with U_i values
            const preview = document.getElementById('msPreview');
            let previewHTML = '<strong>Middle-Square Method Results (showing first 10):</strong><br><br>';
            previewHTML += '<table style="width:100%; font-size:0.9em; border-collapse: collapse;">';
            previewHTML += '<tr><th style="border:1px solid #ccc; padding:4px;">i</th><th style="border:1px solid #ccc; padding:4px;">Z_i</th><th style="border:1px solid #ccc; padding:4px;">U_i</th><th style="border:1px solid #ccc; padding:4px;">Z_i²</th></tr>';
            
            // Show first 10 entries
            const displayCount = Math.min(10, middleSquareData.length);
            for (let i = 0; i < displayCount; i++) {
                const data = middleSquareData[i];
                previewHTML += `<tr>
                    <td style="border:1px solid #ccc; padding:4px;">${data.i}</td>
                    <td style="border:1px solid #ccc; padding:4px;">${data.Zi}</td>
                    <td style="border:1px solid #ccc; padding:4px;">${data.Ui.toFixed(2)}</td>
                    <td style="border:1px solid #ccc; padding:4px;">${data.ZiSquared}</td>
                </tr>`;
            }
            
            previewHTML += '</table>';
            
            if (middleSquareData.length > 10) {
                previewHTML += `<p style="margin-top:5px;">... plus ${middleSquareData.length - 10} more entries</p>`;
            }
            
            // Show generated random numbers (01-100)
            previewHTML += `<br><strong>Generated Random Numbers (01-100 from U_i × 100):</strong><br>`;
            previewHTML += numbers.slice(0, 20).join(', ') + 
                (numbers.length > 20 ? `... (${numbers.length} total)` : '');
            
            preview.innerHTML = previewHTML;
            
            showNotification(`Generated ${numbers.length} numbers using Middle-Square method`, 'success');
            
            return numbers;
        }
        
        // Linear Congruential Generator - SIMPLE: U_i × 100 = random number (NO ROUNDING)
        function generateLCG() {
            const seed = parseInt(document.getElementById('lcgSeed').value);
            const multiplier = parseInt(document.getElementById('lcgMultiplier').value);
            const increment = parseInt(document.getElementById('lcgIncrement').value);
            const modulus = parseInt(document.getElementById('lcgModulus').value);
            const count = parseInt(document.getElementById('lcgCount').value);
            
            if (isNaN(seed) || isNaN(multiplier) || isNaN(increment) || isNaN(modulus) || isNaN(count)) {
                showNotification('Please enter valid numbers for all parameters', 'error');
                return;
            }
            
            if (modulus <= 0) {
                showNotification('Modulus must be greater than 0', 'error');
                return;
            }
            
            let numbers = [];
            let lcgData = []; // Store data for display
            let current = seed;
            
            for (let i = 0; i < count; i++) {
                // Calculate next number using LCG formula
                current = (multiplier * current + increment) % modulus;
                
                // Get U_i value between 0 and 1 (this is the exact UI value)
                const u_i = current / modulus;
                
                // Store data for display
                lcgData.push({
                    i: i,
                    Zi: current,
                    Ui: u_i,
                    ZiPrev: i === 0 ? seed : lcgData[i-1].Zi
                });
                
                // Generate random number: U_i × 100 = 00-99, +1 = 01-100
                // NO ROUNDING - just floor it like in middle-square
                let randomNumber = Math.floor(u_i * 100) + 1;
                
                // Ensure number is between 1-100
                numbers.push(Math.max(1, Math.min(100, randomNumber)));
            }
            
            lastGeneratedNumbers = numbers;
            
            // Display preview
            const preview = document.getElementById('lcgPreview');
            let previewHTML = '<strong>LCG Results (showing first 10):</strong><br><br>';
            previewHTML += '<table style="width:100%; font-size:0.9em; border-collapse: collapse;">';
            previewHTML += '<tr><th style="border:1px solid #ccc; padding:4px;">i</th><th style="border:1px solid #ccc; padding:4px;">Z_i</th><th style="border:1px solid #ccc; padding:4px;">U_i</th><th style="border:1px solid #ccc; padding:4px;">Random #</th></tr>';
            
            // Show first 10 entries
            const displayCount = Math.min(10, lcgData.length);
            for (let i = 0; i < displayCount; i++) {
                const data = lcgData[i];
                const randomNum = Math.floor(data.Ui * 100) + 1;
                previewHTML += `<tr>
                    <td style="border:1px solid #ccc; padding:4px;">${data.i}</td>
                    <td style="border:1px solid #ccc; padding:4px;">${data.Zi}</td>
                    <td style="border:1px solid #ccc; padding:4px;">${data.Ui.toFixed(4)}</td>
                    <td style="border:1px solid #ccc; padding:4px;">${String(randomNum).padStart(2, '0')}</td>
                </tr>`;
            }
            
            previewHTML += '</table>';
            
            if (lcgData.length > 10) {
                previewHTML += `<p style="margin-top:5px;">... plus ${lcgData.length - 10} more entries</p>`;
            }
            
            // Show generated random numbers
            previewHTML += `<br><strong>Generated Random Numbers (01-100 from U_i × 100):</strong><br>`;
            previewHTML += numbers.slice(0, 20).join(', ') + 
                (numbers.length > 20 ? `... (${numbers.length} total)` : '');
            
            preview.innerHTML = previewHTML;
            
            showNotification(`Generated ${numbers.length} numbers using LCG method`, 'success');
            
            return numbers;
        }
        
        function useGeneratedForArrival() {
            if (lastGeneratedNumbers.length === 0) {
                showNotification('Please generate numbers first', 'error');
                return;
            }
            
            document.getElementById('arrivalRandoms').value = lastGeneratedNumbers.join(', ');
            showNotification(`Applied ${lastGeneratedNumbers.length} numbers to Arrival`, 'success');
        }
        
        function useGeneratedForService() {
            if (lastGeneratedNumbers.length === 0) {
                showNotification('Please generate numbers first', 'error');
                return;
            }
            
            document.getElementById('serviceRandoms').value = lastGeneratedNumbers.join(', ');
            showNotification(`Applied ${lastGeneratedNumbers.length} numbers to Service`, 'success');
        }
        
        function generateBothSeparate() {
            // Generate different numbers for arrival and service
            let arrivalNumbers, serviceNumbers;
            
            if (currentRNGMethod === 'middleSquare') {
                // Use different seeds for arrival and service
                const arrivalSeed = parseInt(document.getElementById('msSeed').value);
                const serviceSeed = arrivalSeed + 123; // Different seed
                
                // Temporarily change seed for service
                document.getElementById('msSeed').value = serviceSeed;
                serviceNumbers = generateMiddleSquare();
                
                // Restore original seed and generate arrival numbers
                document.getElementById('msSeed').value = arrivalSeed;
                arrivalNumbers = generateMiddleSquare();
            } else {
                // For LCG, use different seeds
                const arrivalSeed = parseInt(document.getElementById('lcgSeed').value);
                const serviceSeed = arrivalSeed + 456; // Different seed
                
                // Temporarily change seed for service
                document.getElementById('lcgSeed').value = serviceSeed;
                serviceNumbers = generateLCG();
                
                // Restore original seed and generate arrival numbers
                document.getElementById('lcgSeed').value = arrivalSeed;
                arrivalNumbers = generateLCG();
            }
            
            // Apply to both fields
            document.getElementById('arrivalRandoms').value = arrivalNumbers.join(', ');
            document.getElementById('serviceRandoms').value = serviceNumbers.join(', ');
            
            showNotification(`Generated separate numbers for Arrival (${arrivalNumbers.length}) and Service (${serviceNumbers.length})`, 'success');
        }
        
        function generateRandomArrival() {
            let randomNumbers = [];
            let count;
            
            if (simulationLimitType === 'customer') {
                const numCustomers = parseInt(document.getElementById('numCustomers').value);
                count = numCustomers - 1;
            } else {
                count = 100;
            }
            
            for (let i = 0; i < count; i++) {
                // Generate random number between 1-100
                const randomNum = Math.floor(Math.random() * 100) + 1;
                randomNumbers.push(randomNum);
            }
            
            document.getElementById('arrivalRandoms').value = randomNumbers.join(', ');
            showNotification(`Generated ${count} random arrival numbers (01-100)`, 'info');
        }
        
        function generateRandomService() {
            let randomNumbers = [];
            let count;
            
            if (simulationLimitType === 'customer') {
                const numCustomers = parseInt(document.getElementById('numCustomers').value);
                count = numCustomers;
            } else {
                count = 100;
            }
            
            for (let i = 0; i < count; i++) {
                // Generate random number between 1-100
                const randomNum = Math.floor(Math.random() * 100) + 1;
                randomNumbers.push(randomNum);
            }
            
            document.getElementById('serviceRandoms').value = randomNumbers.join(', ');
            showNotification(`Generated ${count} random service numbers (01-100)`, 'info');
        }
        
        function addArrivalRow(time = '', prob = '') {
            const tbody = document.getElementById('arrivalDistributionBody');
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><input type="number" class="arrival-time" value="${time}" min="1" max="100" placeholder="e.g., 1" style="width: 90%; padding: 8px;"></td>
                <td><input type="number" class="arrival-prob" value="${prob}" min="0" max="1" step="0.001" placeholder="0.125" style="width: 90%; padding: 8px;"></td>
                <td class="arrival-cumulative">0.0000</td>
                <td class="arrival-range">01-01</td>
                <td><button onclick="this.parentElement.parentElement.remove(); updateArrivalDistribution()" style="padding: 5px 10px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">Remove</button></td>
            `;
            tbody.appendChild(row);
            
            // Add event listeners to inputs
            row.querySelector('.arrival-time').addEventListener('input', updateArrivalDistribution);
            row.querySelector('.arrival-prob').addEventListener('input', updateArrivalDistribution);
            
            updateArrivalDistribution();
        }
        
        function removeLastArrivalRow() {
            const tbody = document.getElementById('arrivalDistributionBody');
            if (tbody.children.length > 0) {
                tbody.lastElementChild.remove();
                updateArrivalDistribution();
            }
        }
        
        function addServiceRow(time = '', prob = '') {
            const tbody = document.getElementById('serviceDistributionBody');
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><input type="number" class="service-time" value="${time}" min="1" max="100" placeholder="e.g., 1" style="width: 90%; padding: 8px;"></td>
                <td><input type="number" class="service-prob" value="${prob}" min="0" max="1" step="0.001" placeholder="0.10" style="width: 90%; padding: 8px;"></td>
                <td class="service-cumulative">0.0000</td>
                <td class="service-range">01-01</td>
                <td><button onclick="this.parentElement.parentElement.remove(); updateServiceDistribution()" style="padding: 5px 10px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">Remove</button></td>
            `;
            tbody.appendChild(row);
            
            // Add event listeners to inputs
            row.querySelector('.service-time').addEventListener('input', updateServiceDistribution);
            row.querySelector('.service-prob').addEventListener('input', updateServiceDistribution);
            
            updateServiceDistribution();
        }
        
        function removeLastServiceRow() {
            const tbody = document.getElementById('serviceDistributionBody');
            if (tbody.children.length > 0) {
                tbody.lastElementChild.remove();
                updateServiceDistribution();
            }
        }
        
        function updateArrivalDistribution() {
            const rows = document.getElementById('arrivalDistributionBody').children;
            let totalProb = 0;
            let cumulative = 0;
            
            arrivalDistribution = [];
            
            // First pass: collect data
            const probabilities = [];
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                const time = parseFloat(row.querySelector('.arrival-time').value) || 0;
                const prob = parseFloat(row.querySelector('.arrival-prob').value) || 0;
                
                if (time > 0 && prob > 0) {
                    probabilities.push({time: time, prob: prob});
                    totalProb += prob;
                }
            }
            
            // Second pass: assign ranges starting from 01
            let currentRangeStart = 1;
            let accumulatedError = 0;
            
            for (let i = 0; i < probabilities.length; i++) {
                const {time, prob} = probabilities[i];
                
                // Calculate exact number of slots (probability × 100)
                const exactSlots = prob * 100;
                
                // Add accumulated error from previous calculations
                const slotsWithError = exactSlots + accumulatedError;
                
                // Round to nearest integer
                let numSlots = Math.round(slotsWithError);
                
                // Store the error for next iteration
                accumulatedError = slotsWithError - numSlots;
                
                // For last row, adjust to ensure total is exactly 100
                if (i === probabilities.length - 1) {
                    // Calculate what the end range would be
                    const potentialEnd = currentRangeStart + numSlots - 1;
                    if (potentialEnd !== 100) {
                        // Adjust to make sure we end at exactly 100
                        numSlots = 100 - currentRangeStart + 1;
                    }
                }
                
                const endRange = currentRangeStart + numSlots - 1;
                
                cumulative += prob;
                
                arrivalDistribution.push({
                    time: time,
                    probability: prob,
                    cumulative: cumulative,
                    startRange: currentRangeStart,
                    endRange: endRange,
                    numSlots: numSlots
                });
                
                // Update display for corresponding row
                if (rows[i]) {
                    rows[i].querySelector('.arrival-cumulative').textContent = cumulative.toFixed(4);
                    rows[i].querySelector('.arrival-range').textContent = 
                        `${String(currentRangeStart).padStart(2, '0')}–${String(endRange).padStart(2, '0')}`;
                }
                
                currentRangeStart = endRange + 1;
            }
            
            // Update total probability display
            const totalElement = document.getElementById('arrivalProbTotal');
            const tolerance = 0.0001; // Allow small floating point errors
            
            if (Math.abs(totalProb - 1.0) < tolerance) {
                totalElement.textContent = `Total Probability: ${totalProb.toFixed(4)} ✓`;
                totalElement.className = 'probability-ok';
            } else {
                totalElement.textContent = `Total Probability: ${totalProb.toFixed(4)} (Should be 1.0000)`;
                totalElement.className = 'probability-error';
            }
        }
        
        function updateServiceDistribution() {
            const rows = document.getElementById('serviceDistributionBody').children;
            let totalProb = 0;
            let cumulative = 0;
            
            serviceDistribution = [];
            
            // First pass: collect data
            const probabilities = [];
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                const time = parseFloat(row.querySelector('.service-time').value) || 0;
                const prob = parseFloat(row.querySelector('.service-prob').value) || 0;
                
                if (time > 0 && prob > 0) {
                    probabilities.push({time: time, prob: prob});
                    totalProb += prob;
                }
            }
            
            // Second pass: assign ranges starting from 01
            let currentRangeStart = 1;
            let accumulatedError = 0;
            
            for (let i = 0; i < probabilities.length; i++) {
                const {time, prob} = probabilities[i];
                
                // Calculate exact number of slots (probability × 100)
                const exactSlots = prob * 100;
                
                // Add accumulated error from previous calculations
                const slotsWithError = exactSlots + accumulatedError;
                
                // Round to nearest integer
                let numSlots = Math.round(slotsWithError);
                
                // Store the error for next iteration
                accumulatedError = slotsWithError - numSlots;
                
                // For last row, adjust to ensure total is exactly 100
                if (i === probabilities.length - 1) {
                    // Calculate what the end range would be
                    const potentialEnd = currentRangeStart + numSlots - 1;
                    if (potentialEnd !== 100) {
                        // Adjust to make sure we end at exactly 100
                        numSlots = 100 - currentRangeStart + 1;
                    }
                }
                
                const endRange = currentRangeStart + numSlots - 1;
                
                cumulative += prob;
                
                serviceDistribution.push({
                    time: time,
                    probability: prob,
                    cumulative: cumulative,
                    startRange: currentRangeStart,
                    endRange: endRange,
                    numSlots: numSlots
                });
                
                // Update display for corresponding row
                if (rows[i]) {
                    rows[i].querySelector('.service-cumulative').textContent = cumulative.toFixed(4);
                    rows[i].querySelector('.service-range').textContent = 
                        `${String(currentRangeStart).padStart(2, '0')}–${String(endRange).padStart(2, '0')}`;
                }
                
                currentRangeStart = endRange + 1;
            }
            
            // Update total probability display
            const totalElement = document.getElementById('serviceProbTotal');
            const tolerance = 0.0001; // Allow small floating point errors
            
            if (Math.abs(totalProb - 1.0) < tolerance) {
                totalElement.textContent = `Total Probability: ${totalProb.toFixed(4)} ✓`;
                totalElement.className = 'probability-ok';
            } else {
                totalElement.textContent = `Total Probability: ${totalProb.toFixed(4)} (Should be 1.0000)`;
                totalElement.className = 'probability-error';
            }
        }
        
        function loadExampleFromPDF() {
            // Clear existing rows
            document.getElementById('arrivalDistributionBody').innerHTML = '';
            document.getElementById('serviceDistributionBody').innerHTML = '';
            
            // Load uniform arrival distribution (1-8, each with probability 0.125)
            const arrivalTimes = [1, 2, 3, 4, 5, 6, 7, 8];
            const arrivalProb = 0.125; // Each has probability 0.125
            
            arrivalTimes.forEach(time => {
                addArrivalRow(time, arrivalProb);
            });
            
            // Load the specific service distribution from your image
            const serviceData = [
                {time: 1, prob: 0.10},
                {time: 2, prob: 0.20},
                {time: 3, prob: 0.30},
                {time: 4, prob: 0.25},
                {time: 5, prob: 0.10},
                {time: 6, prob: 0.05}
            ];
            
            serviceData.forEach(data => {
                addServiceRow(data.time, data.prob);
            });
            
            // Convert PDF example random numbers from 3-digit to 2-digit
            const pdfArrivalRandoms = [913, 727, 015, 948, 309, 922, 753, 235, 302, 109, 093, 607, 738, 359, 888, 106, 212, 493, 535];
            // Scale to 01-100 range
            const scaledArrivalRandoms = pdfArrivalRandoms.map(num => {
                // Take first two digits of 3-digit number
                const twoDigit = Math.floor(num / 10);
                return twoDigit + 1; // Convert to 1-100 range
            });
            
            // PDF service numbers are already 2-digit, convert to 1-100 range
            const pdfServiceRandoms = [84, 10, 74, 53, 17, 79, 91, 67, 89, 38, 32, 94, 79, 5, 79, 84, 52, 55, 30, 50];
            const scaledServiceRandoms = pdfServiceRandoms.map(num => num + 1); // Convert to 1-100 range
            
            document.getElementById('arrivalRandoms').value = scaledArrivalRandoms.join(', ');
            document.getElementById('serviceRandoms').value = scaledServiceRandoms.join(', ');
            
            // Set number of customers to 20 (as in PDF example)
            document.getElementById('numCustomers').value = 20;
            document.getElementById('timeLimit').value = 100;
            
            // Update distributions
            updateArrivalDistribution();
            updateServiceDistribution();
            
            showNotification('Loaded PDF example successfully', 'success');
            
            // Automatically run simulation with PDF data
            setTimeout(() => {
                runSingleQueueSimulation();
            }, 500);
        }
        
        // FIXED: Normalize random numbers - handles both UI format (0.00-0.99) and direct format (1-100)
        function normalizeRandomNumber(num) {
            // Parse as float
            const n = parseFloat(num);
            if (isNaN(n)) return 1;
            
            // Check if number is in UI format (0.00-0.99) or direct format (1-100)
            if (n < 1) {
                // UI format: multiply by 100 to get 1-100
                return Math.max(1, Math.min(100, Math.floor(n * 100)));
            } else {
                // Direct format: already 1-100, just ensure it's in range
                return Math.max(1, Math.min(100, Math.floor(n)));
            }
        }
        
        function mapRandomToArrivalTime(randomDigit) {
            // Normalize random number using the updated function
            const randomValue = normalizeRandomNumber(randomDigit);
            
            if (arrivalDistribution.length === 0) {
                showNotification('Please define arrival distribution first', 'error');
                return 1;
            }
            
            // Find which range the random number falls into
            for (let dist of arrivalDistribution) {
                if (randomValue >= dist.startRange && randomValue <= dist.endRange) {
                    return dist.time;
                }
            }
            
            // If not found (edge case), use last distribution
            return arrivalDistribution[arrivalDistribution.length - 1].time;
        }
        
        function mapRandomToServiceTime(randomDigit) {
            // Normalize random number using the updated function
            const randomValue = normalizeRandomNumber(randomDigit);
            
            if (serviceDistribution.length === 0) {
                showNotification('Please define service distribution first', 'error');
                return 1;
            }
            
            // Find which range the random number falls into
            for (let dist of serviceDistribution) {
                if (randomValue >= dist.startRange && randomValue <= dist.endRange) {
                    return dist.time;
                }
            }
            
            // If not found (edge case), use last distribution
            return serviceDistribution[serviceDistribution.length - 1].time;
        }
        
        function showNotification(message, type) {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                border-radius: 5px;
                color: white;
                font-weight: 600;
                z-index: 1000;
                animation: slideIn 0.3s ease-out;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;
            
            if (type === 'success') {
                notification.style.backgroundColor = '#2ecc71';
            } else if (type === 'error') {
                notification.style.backgroundColor = '#e74c3c';
            } else {
                notification.style.backgroundColor = '#3498db';
            }
            
            notification.textContent = message;
            document.body.appendChild(notification);
            
            // Remove notification after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
            
            // Add CSS for animations
            if (!document.querySelector('#notification-styles')) {
                const style = document.createElement('style');
                style.id = 'notification-styles';
                style.textContent = `
                    @keyframes slideIn {
                        from {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                        to {
                            transform: translateX(0);
                            opacity: 1;
                        }
                    }
                    @keyframes slideOut {
                        from {
                            transform: translateX(0);
                            opacity: 1;
                        }
                        to {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        function runSingleQueueSimulation() {
            // Validate distributions
            if (arrivalDistribution.length === 0) {
                showNotification('Please define arrival time distribution', 'error');
                return;
            }
            
            if (serviceDistribution.length === 0) {
                showNotification('Please define service time distribution', 'error');
                return;
            }
            
            // Check if probabilities sum to 1 (with tolerance)
            const arrivalTotal = arrivalDistribution.reduce((sum, dist) => sum + dist.probability, 0);
            const serviceTotal = serviceDistribution.reduce((sum, dist) => sum + dist.probability, 0);
            const tolerance = 0.0001;
            
            if (Math.abs(arrivalTotal - 1.0) > tolerance) {
                showNotification('Arrival probabilities must sum to exactly 1.0000', 'error');
                return;
            }
            
            if (Math.abs(serviceTotal - 1.0) > tolerance) {
                showNotification('Service probabilities must sum to exactly 1.0000', 'error');
                return;
            }
            
            // Parse random numbers
            const arrivalInput = document.getElementById('arrivalRandoms').value.trim();
            const serviceInput = document.getElementById('serviceRandoms').value.trim();
            
            if (!arrivalInput || !serviceInput) {
                showNotification('Please provide both arrival and service random numbers', 'error');
                return;
            }
            
            // FIXED: Parse random numbers - use the updated normalization function
            const arrivalRandoms = arrivalInput.split(',')
                .map(r => r.trim())
                .filter(r => r !== '')
                .map(num => {
                    const n = parseFloat(num);
                    if (isNaN(n)) return 1;
                    return n; // Keep as is, let normalizeRandomNumber handle conversion
                });

            const serviceRandoms = serviceInput.split(',')
                .map(r => r.trim())
                .filter(r => r !== '')
                .map(num => {
                    const n = parseFloat(num);
                    if (isNaN(n)) return 1;
                    return n; // Keep as is, let normalizeRandomNumber handle conversion
                });

            // Ensure numbers are between 1-100 using the fixed normalize function
            const normalizedArrivalRandoms = arrivalRandoms.map(num => normalizeRandomNumber(num));
            const normalizedServiceRandoms = serviceRandoms.map(num => normalizeRandomNumber(num));
            
            // Run simulation based on limit type
            let simulation;
            if (simulationLimitType === 'customer') {
                const numCustomers = parseInt(document.getElementById('numCustomers').value);
                
                if (normalizedArrivalRandoms.length < numCustomers - 1) {
                    showNotification(`Need ${numCustomers - 1} arrival random numbers, got ${normalizedArrivalRandoms.length}`, 'error');
                    return;
                }
                
                if (normalizedServiceRandoms.length < numCustomers) {
                    showNotification(`Need ${numCustomers} service random numbers, got ${normalizedServiceRandoms.length}`, 'error');
                    return;
                }
                
                simulation = simulateByCustomerLimit(numCustomers, normalizedArrivalRandoms, normalizedServiceRandoms);
            } else {
                const timeLimit = parseInt(document.getElementById('timeLimit').value);
                
                if (normalizedArrivalRandoms.length < 1) {
                    showNotification('Need at least 1 arrival random number for time limit simulation', 'error');
                    return;
                }
                
                if (normalizedServiceRandoms.length < 1) {
                    showNotification('Need at least 1 service random number for time limit simulation', 'error');
                    return;
                }
                
                simulation = simulateByTimeLimit(timeLimit, normalizedArrivalRandoms, normalizedServiceRandoms);
            }
            
            currentSimulation = simulation;
            
            // Display results
            displaySingleQueueResults(simulation);
            
            showNotification(`Simulated ${simulation.totalCustomers} customers successfully`, 'success');
        }
        
        function simulateByCustomerLimit(numCustomers, arrivalRandoms, serviceRandoms) {
            // Map random numbers to times for the required number of customers
            let interarrivalTimes = [];
            for (let i = 0; i < numCustomers - 1; i++) {
                if (i >= arrivalRandoms.length) {
                    // If we run out of random numbers, generate more (01-100)
                    arrivalRandoms.push(Math.floor(Math.random() * 100) + 1);
                }
                interarrivalTimes.push(mapRandomToArrivalTime(arrivalRandoms[i]));
            }
            
            let serviceTimes = [];
            for (let i = 0; i < numCustomers; i++) {
                if (i >= serviceRandoms.length) {
                    // If we run out of random numbers, generate more (01-100)
                    serviceRandoms.push(Math.floor(Math.random() * 100) + 1);
                }
                serviceTimes.push(mapRandomToServiceTime(serviceRandoms[i]));
            }
            
            // Run simulation
            return simulateSingleQueue(interarrivalTimes, serviceTimes, arrivalRandoms.slice(0, numCustomers - 1), serviceRandoms.slice(0, numCustomers));
        }
        
        function simulateByTimeLimit(timeLimit, arrivalRandoms, serviceRandoms) {
            let customers = [];
            let totalWaitTime = 0;
            let totalSystemTime = 0;
            let totalIdleTime = 0;
            let numWaiting = 0;
            
            let clock = 0;
            let serviceEndTime = 0;
            let customerCount = 0;
            let arrivalRandomIndex = 0;
            let serviceRandomIndex = 0;
            
            // Generate first customer
            customers.push({
                customer: 1,
                arrivalRandom: '-',
                interarrivalTime: '-',
                arrivalTime: 0,
                serviceRandom: serviceRandoms[serviceRandomIndex],
                serviceTime: mapRandomToServiceTime(serviceRandoms[serviceRandomIndex]),
                timeServiceBegins: 0,
                timeServiceEnds: 0,
                waitTime: 0,
                systemTime: 0,
                idleTime: 0
            });
            serviceRandomIndex++;
            customerCount = 1;
            
            // Process customers until time limit is reached
            while (clock <= timeLimit) {
                const currentCustomer = customers[customerCount - 1];
                
                // Calculate when service begins for current customer
                let timeServiceBegins;
                if (currentCustomer.arrivalTime >= serviceEndTime) {
                    timeServiceBegins = currentCustomer.arrivalTime;
                    totalIdleTime += (currentCustomer.arrivalTime - serviceEndTime);
                } else {
                    timeServiceBegins = serviceEndTime;
                }
                
                const serviceTime = currentCustomer.serviceTime;
                const timeServiceEnds = timeServiceBegins + serviceTime;
                const waitTime = timeServiceBegins - currentCustomer.arrivalTime;
                const systemTime = timeServiceEnds - currentCustomer.arrivalTime;
                
                if (waitTime > 0) {
                    numWaiting++;
                }
                
                totalWaitTime += waitTime;
                totalSystemTime += systemTime;
                
                // Update current customer
                currentCustomer.timeServiceBegins = timeServiceBegins;
                currentCustomer.timeServiceEnds = timeServiceEnds;
                currentCustomer.waitTime = waitTime;
                currentCustomer.systemTime = systemTime;
                
                // Update clock
                clock = Math.max(clock, timeServiceEnds);
                serviceEndTime = timeServiceEnds;
                
                // Check if we should stop (time limit reached)
                if (clock > timeLimit) {
                    // Don't add next customer if time limit exceeded
                    break;
                }
                
                // Generate next customer if we have random numbers
                if (arrivalRandomIndex < arrivalRandoms.length && serviceRandomIndex < serviceRandoms.length) {
                    const interarrivalTime = mapRandomToArrivalTime(arrivalRandoms[arrivalRandomIndex]);
                    const nextArrivalTime = currentCustomer.arrivalTime + interarrivalTime;
                    
                    // Check if next arrival is within time limit
                    if (nextArrivalTime > timeLimit) {
                        break;
                    }
                    
                    const nextServiceTime = mapRandomToServiceTime(serviceRandoms[serviceRandomIndex]);
                    
                    customers.push({
                        customer: customerCount + 1,
                        arrivalRandom: arrivalRandoms[arrivalRandomIndex],
                        interarrivalTime: interarrivalTime,
                        arrivalTime: nextArrivalTime,
                        serviceRandom: serviceRandoms[serviceRandomIndex],
                        serviceTime: nextServiceTime,
                        timeServiceBegins: 0, // Will be calculated in next iteration
                        timeServiceEnds: 0,
                        waitTime: 0,
                        systemTime: 0,
                        idleTime: Math.max(0, nextArrivalTime - currentCustomer.timeServiceEnds)
                    });
                    
                    arrivalRandomIndex++;
                    serviceRandomIndex++;
                    customerCount++;
                } else {
                    // No more random numbers, stop simulation
                    break;
                }
            }
            
            // Calculate actual simulation end time (last service completion)
            const actualEndTime = customers[customers.length - 1].timeServiceEnds;
            
            return {
                customers: customers,
                totalWaitTime: totalWaitTime,
                totalSystemTime: totalSystemTime,
                totalIdleTime: totalIdleTime,
                numWaiting: numWaiting,
                totalCustomers: customers.length,
                simulationEndTime: actualEndTime,
                arrivalRandoms: arrivalRandoms.slice(0, arrivalRandomIndex),
                serviceRandoms: serviceRandoms.slice(0, serviceRandomIndex),
                limitType: 'time',
                timeLimit: timeLimit
            };
        }
        
        function simulateSingleQueue(interarrivalTimes, serviceTimes, arrivalRandoms, serviceRandoms) {
            let customers = [];
            let totalWaitTime = 0;
            let totalSystemTime = 0;
            let totalIdleTime = 0;
            let numWaiting = 0;
            
            let clock = 0;
            let serviceEndTime = 0;
            
            for (let i = 0; i < serviceTimes.length; i++) {
                // Calculate arrival time
                let arrivalTime;
                if (i === 0) {
                    arrivalTime = 0;
                } else {
                    arrivalTime = customers[i-1].arrivalTime + interarrivalTimes[i-1];
                }
                
                // Calculate when service begins
                let timeServiceBegins;
                if (arrivalTime >= serviceEndTime) {
                    timeServiceBegins = arrivalTime;
                    totalIdleTime += (arrivalTime - serviceEndTime);
                } else {
                    timeServiceBegins = serviceEndTime;
                }
                
                const serviceTime = serviceTimes[i];
                const timeServiceEnds = timeServiceBegins + serviceTime;
                const waitTime = timeServiceBegins - arrivalTime;
                const systemTime = timeServiceEnds - arrivalTime;
                
                if (waitTime > 0) {
                    numWaiting++;
                }
                
                totalWaitTime += waitTime;
                totalSystemTime += systemTime;
                
                customers.push({
                    customer: i + 1,
                    arrivalRandom: i === 0 ? '-' : arrivalRandoms[i-1],
                    interarrivalTime: i === 0 ? '-' : interarrivalTimes[i-1],
                    arrivalTime: arrivalTime,
                    serviceRandom: serviceRandoms[i],
                    serviceTime: serviceTime,
                    timeServiceBegins: timeServiceBegins,
                    timeServiceEnds: timeServiceEnds,
                    waitTime: waitTime,
                    systemTime: systemTime,
                    idleTime: i === 0 ? 0 : Math.max(0, arrivalTime - customers[i-1].timeServiceEnds)
                });
                
                serviceEndTime = timeServiceEnds;
                clock = timeServiceEnds;
            }
            
            return {
                customers: customers,
                totalWaitTime: totalWaitTime,
                totalSystemTime: totalSystemTime,
                totalIdleTime: totalIdleTime,
                numWaiting: numWaiting,
                totalCustomers: customers.length,
                simulationEndTime: clock,
                arrivalRandoms: arrivalRandoms,
                serviceRandoms: serviceRandoms,
                limitType: 'customer'
            };
        }
        
        function displaySingleQueueResults(simulation) {
            const { customers, totalWaitTime, totalSystemTime, totalIdleTime, numWaiting, totalCustomers, simulationEndTime, limitType } = simulation;
            
            // Calculate performance measures
            const avgWaitTime = totalWaitTime / totalCustomers;
            const avgSystemTime = totalSystemTime / totalCustomers;
            const probWait = numWaiting / totalCustomers;
            const probIdle = totalIdleTime / simulationEndTime;
            const avgServiceTime = customers.reduce((sum, cust) => sum + cust.serviceTime, 0) / totalCustomers;
            const avgInterarrivalTime = customers.slice(1).reduce((sum, cust) => sum + cust.interarrivalTime, 0) / (totalCustomers - 1);
            
            // Add export buttons for results
            const exportButtonsHTML = `
                <div class="export-buttons" style="margin-top: 20px;">
                    <button class="export-btn pdf" onclick="printPDF()">
                        <i class="fas fa-print"></i> Print PDF
                    </button>
                    <button class="export-btn excel" onclick="exportToExcel()">
                        <i class="fas fa-file-excel"></i> Export to Excel
                    </button>
                </div>
            `;
            
            // Show simulation limit info
            let limitInfoHTML = '';
            if (limitType === 'time') {
                const timeLimit = document.getElementById('timeLimit').value;
                limitInfoHTML = `
                    <div class="warning">
                        <strong>Simulation Limit:</strong> Time Limit of ${timeLimit} minutes<br>
                        <strong>Actual Simulation Time:</strong> ${simulationEndTime.toFixed(1)} minutes<br>
                        <strong>Number of Customers Served:</strong> ${totalCustomers}
                    </div>
                `;
            } else {
                limitInfoHTML = `
                    <div class="warning">
                        <strong>Simulation Limit:</strong> Customer Limit of ${totalCustomers} customers<br>
                        <strong>Simulation End Time:</strong> ${simulationEndTime} minutes
                    </div>
                `;
            }
            
            // Show distribution tables WITH "# of Slots" column
            let distributionHTML = `
                <h3 class="results-header">Arrival Time Distribution</h3>
                <table class="distribution-table">
                    <thead>
                        <tr>
                            <th>Time Between Arrivals</th>
                            <th>Probability</th>
                            <th>Cumulative</th>
                            <th>Random-Digit Assignment</th>
                            <th># of Slots</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            arrivalDistribution.forEach(dist => {
                distributionHTML += `
                    <tr>
                        <td>${dist.time} minutes</td>
                        <td>${dist.probability.toFixed(4)}</td>
                        <td>${dist.cumulative.toFixed(4)}</td>
                        <td>${String(dist.startRange).padStart(2, '0')}–${String(dist.endRange).padStart(2, '0')}</td>
                        <td>${dist.numSlots}</td>
                    </tr>
                `;
            });
            
            distributionHTML += `
                    </tbody>
                </table>
                
                <h3 class="results-header">Service Time Distribution</h3>
                <table class="distribution-table">
                    <thead>
                        <tr>
                            <th>Service Time</th>
                            <th>Probability</th>
                            <th>Cumulative</th>
                            <th>Random-Digit Assignment</th>
                            <th># of Slots</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            serviceDistribution.forEach(dist => {
                distributionHTML += `
                    <tr>
                        <td>${dist.time} minutes</td>
                        <td>${dist.probability.toFixed(4)}</td>
                        <td>${dist.cumulative.toFixed(4)}</td>
                        <td>${String(dist.startRange).padStart(2, '0')}–${String(dist.endRange).padStart(2, '0')}</td>
                        <td>${dist.numSlots}</td>
                    </tr>
                `;
            });
            
            distributionHTML += `
                    </tbody>
                </table>
            `;
            
            // Create simulation table
            let tableHTML = `
                <h3 class="results-header">Simulation Table for ${totalCustomers} Customers</h3>
                ${limitInfoHTML}
                <div class="simulation-table-container">
                    <table class="simulation-table">
                        <thead>
                            <tr>
                                <th>Cust #</th>
                                <th>Arrival Random</th>
                                <th>Interarrival Time</th>
                                <th>Arrival Time</th>
                                <th>Service Random</th>
                                <th>Service Time</th>
                                <th>Time Service Begins</th>
                                <th>Time Service Ends</th>
                                <th>Wait Time</th>
                                <th>System Time</th>
                                <th>Idle Time</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            customers.forEach(customer => {
                tableHTML += `
                    <tr>
                        <td>${customer.customer}</td>
                        <td>${String(customer.arrivalRandom).padStart(2, '0')}</td>
                        <td>${customer.interarrivalTime}</td>
                        <td>${customer.arrivalTime}</td>
                        <td>${String(customer.serviceRandom).padStart(2, '0')}</td>
                        <td>${customer.serviceTime}</td>
                        <td>${customer.timeServiceBegins}</td>
                        <td>${customer.timeServiceEnds}</td>
                        <td>${customer.waitTime}</td>
                        <td>${customer.systemTime}</td>
                        <td>${customer.idleTime}</td>
                    </tr>
                `;
            });
            
            tableHTML += `
                        <tr style="background-color: #f8f9fa; font-weight: bold;">
                            <td colspan="8"><strong>Totals / Averages</strong></td>
                            <td><strong>${totalWaitTime}</strong><br>(${avgWaitTime.toFixed(2)} avg)</td>
                            <td><strong>${totalSystemTime}</strong><br>(${avgSystemTime.toFixed(2)} avg)</td>
                            <td><strong>${totalIdleTime.toFixed(1)}</strong></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            `;
            
            // Create summary cards
            const summaryHTML = `
                <h3 class="results-header">Performance Measures</h3>
                <div class="summary-cards">
                    <div class="summary-card">
                        <h4>Average Waiting Time</h4>
                        <div class="value">${avgWaitTime.toFixed(2)}</div>
                        <div class="unit">minutes</div>
                    </div>
                    <div class="summary-card">
                        <h4>Probability of Waiting</h4>
                        <div class="value">${(probWait * 100).toFixed(1)}%</div>
                        <div class="unit">${numWaiting}/${totalCustomers} customers</div>
                    </div>
                    <div class="summary-card">
                        <h4>Server Idle Probability</h4>
                        <div class="value">${(probIdle * 100).toFixed(1)}%</div>
                        <div class="unit">${totalIdleTime.toFixed(1)}/${simulationEndTime.toFixed(1)} minutes</div>
                    </div>
                    <div class="summary-card">
                        <h4>Average Service Time</h4>
                        <div class="value">${avgServiceTime.toFixed(2)}</div>
                        <div class="unit">minutes</div>
                    </div>
                    <div class="summary-card">
                        <h4>Average Interarrival Time</h4>
                        <div class="value">${avgInterarrivalTime.toFixed(2)}</div>
                        <div class="unit">minutes</div>
                    </div>
                    <div class="summary-card">
                        <h4>Average Time in System</h4>
                        <div class="value">${avgSystemTime.toFixed(2)}</div>
                        <div class="unit">minutes</div>
                    </div>
                </div>
            `;
            
            // Combine everything
            document.getElementById('resultsSection').innerHTML = `
                ${exportButtonsHTML}
                ${distributionHTML}
                ${tableHTML}
                ${summaryHTML}
            `;
        }
        
        function printPDF() {
            window.print();
        }
        
        function exportToExcel() {
            if (!currentSimulation) {
                showNotification('Please run a simulation first', 'error');
                return;
            }
            
            // Create workbook
            const wb = XLSX.utils.book_new();
            
            // Add Simulation Parameters Sheet
            const paramsData = [
                ['Single Server Queue Simulation - Parameters'],
                [],
                ['Simulation Limit Type:', currentSimulation.limitType === 'customer' ? 'Customer Limit' : 'Time Limit'],
                currentSimulation.limitType === 'customer' 
                    ? ['Number of Customers:', currentSimulation.totalCustomers]
                    : ['Time Limit (minutes):', document.getElementById('timeLimit').value],
                ['Actual Customers Served:', currentSimulation.totalCustomers],
                ['Simulation End Time:', currentSimulation.simulationEndTime.toFixed(1) + ' minutes'],
                [],
                ['Arrival Time Distribution']
            ];
            
            // Add arrival distribution
            paramsData.push(['Time Between Arrivals (minutes)', 'Probability', 'Cumulative Probability', 'Random-Digit Assignment', '# of Slots']);
            arrivalDistribution.forEach(dist => {
                paramsData.push([
                    dist.time,
                    dist.probability,
                    dist.cumulative,
                    `${String(dist.startRange).padStart(2, '0')}–${String(dist.endRange).padStart(2, '0')}`,
                    dist.numSlots
                ]);
            });
            
            paramsData.push([]);
            paramsData.push(['Service Time Distribution']);
            paramsData.push(['Service Time (minutes)', 'Probability', 'Cumulative Probability', 'Random-Digit Assignment', '# of Slots']);
            serviceDistribution.forEach(dist => {
                paramsData.push([
                    dist.time,
                    dist.probability,
                    dist.cumulative,
                    `${String(dist.startRange).padStart(2, '0')}–${String(dist.endRange).padStart(2, '0')}`,
                    dist.numSlots
                ]);
            });
            
            const paramsWs = XLSX.utils.aoa_to_sheet(paramsData);
            XLSX.utils.book_append_sheet(wb, paramsWs, "Parameters");
            
            // Add Simulation Results Sheet
            const simulationData = [
                ['Simulation Results - Single Server Queue'],
                ['Simulation Limit:', currentSimulation.limitType === 'customer' ? 'Customer Limit' : 'Time Limit'],
                currentSimulation.limitType === 'customer' 
                    ? ['Number of Customers:', currentSimulation.totalCustomers]
                    : ['Time Limit (minutes):', document.getElementById('timeLimit').value],
                ['Actual Customers Served:', currentSimulation.totalCustomers],
                ['Simulation End Time:', currentSimulation.simulationEndTime.toFixed(1) + ' minutes'],
                [],
                ['Customer #', 'Arrival Random', 'Interarrival Time', 'Arrival Time', 'Service Random', 
                 'Service Time', 'Time Service Begins', 'Time Service Ends', 'Wait Time', 'System Time', 'Idle Time']
            ];
            
            currentSimulation.customers.forEach(customer => {
                simulationData.push([
                    customer.customer,
                    customer.arrivalRandom === '-' ? '-' : String(customer.arrivalRandom).padStart(2, '0'),
                    customer.interarrivalTime === '-' ? '-' : customer.interarrivalTime,
                    customer.arrivalTime,
                    String(customer.serviceRandom).padStart(2, '0'),
                    customer.serviceTime,
                    customer.timeServiceBegins,
                    customer.timeServiceEnds,
                    customer.waitTime,
                    customer.systemTime,
                    customer.idleTime
                ]);
            });
            
            // Add summary statistics
            const avgWaitTime = currentSimulation.totalWaitTime / currentSimulation.totalCustomers;
            const avgSystemTime = currentSimulation.totalSystemTime / currentSimulation.totalCustomers;
            const probWait = currentSimulation.numWaiting / currentSimulation.totalCustomers;
            const probIdle = currentSimulation.totalIdleTime / currentSimulation.simulationEndTime;
            const avgServiceTime = currentSimulation.customers.reduce((sum, cust) => sum + cust.serviceTime, 0) / currentSimulation.totalCustomers;
            const avgInterarrivalTime = currentSimulation.customers.slice(1).reduce((sum, cust) => sum + cust.interarrivalTime, 0) / (currentSimulation.totalCustomers - 1);
            
            simulationData.push([]);
            simulationData.push(['Summary Statistics']);
            simulationData.push(['Total Customers:', currentSimulation.totalCustomers]);
            simulationData.push(['Total Wait Time:', currentSimulation.totalWaitTime]);
            simulationData.push(['Average Wait Time:', avgWaitTime.toFixed(2)]);
            simulationData.push(['Number of Customers Who Waited:', currentSimulation.numWaiting]);
            simulationData.push(['Probability of Waiting:', (probWait * 100).toFixed(1) + '%']);
            simulationData.push(['Server Idle Time:', currentSimulation.totalIdleTime]);
            simulationData.push(['Server Idle Probability:', (probIdle * 100).toFixed(1) + '%']);
            simulationData.push(['Total System Time:', currentSimulation.totalSystemTime]);
            simulationData.push(['Average System Time:', avgSystemTime.toFixed(2)]);
            simulationData.push(['Average Service Time:', avgServiceTime.toFixed(2)]);
            simulationData.push(['Average Interarrival Time:', avgInterarrivalTime.toFixed(2)]);
            simulationData.push(['Simulation End Time:', currentSimulation.simulationEndTime.toFixed(1)]);
            
            const simulationWs = XLSX.utils.aoa_to_sheet(simulationData);
            XLSX.utils.book_append_sheet(wb, simulationWs, "Simulation Results");
            
            // Generate and download Excel file
            const fileName = `Queue_Simulation_${currentSimulation.limitType}_${new Date().toISOString().slice(0,10)}.xlsx`;
            XLSX.writeFile(wb, fileName);
            
            showNotification(`Excel file "${fileName}" has been downloaded`, 'success');
        }
    </script>
    </body>
</html>